---
title: ASP.NET Core 中的会话
author: rick-anderson
description: 发现保留请求间会话的方法。
ms.author: riande
ms.custom: mvc
ms.date: 03/06/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: fundamentals/app-state
ms.openlocfilehash: ab09867a1b1aa73e423babbe295036e292fc733f
ms.sourcegitcommit: 54fe1ae5e7d068e27376d562183ef9ddc7afc432
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/10/2021
ms.locfileid: "102586574"
---
# <a name="session-and-state-management-in-aspnet-core"></a><span data-ttu-id="2dd9d-103">ASP.NET Core 中的会话和状态管理</span><span class="sxs-lookup"><span data-stu-id="2dd9d-103">Session and state management in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="2dd9d-104">作者：[Rick Anderson](https://twitter.com/RickAndMSFT)、[Kirk Larkin](https://twitter.com/serpent5) 和 [Diana LaRose](https://github.com/DianaLaRose)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [Kirk Larkin](https://twitter.com/serpent5), and [Diana LaRose](https://github.com/DianaLaRose)</span></span>

<span data-ttu-id="2dd9d-105">HTTP 是无状态的协议。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-105">HTTP is a stateless protocol.</span></span> <span data-ttu-id="2dd9d-106">默认情况下，HTTP 请求是不保留用户值的独立消息。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-106">By default, HTTP requests are independent messages that don't retain user values.</span></span> <span data-ttu-id="2dd9d-107">本文介绍了几种保留请求间用户数据的方法。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-107">This article describes several approaches to preserve user data between requests.</span></span>

<span data-ttu-id="2dd9d-108">[查看或下载示例代码](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/app-state/samples)（[如何下载](xref:index#how-to-download-a-sample)）</span><span class="sxs-lookup"><span data-stu-id="2dd9d-108">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/app-state/samples) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="state-management"></a><span data-ttu-id="2dd9d-109">状态管理</span><span class="sxs-lookup"><span data-stu-id="2dd9d-109">State management</span></span>

<span data-ttu-id="2dd9d-110">可以使用几种方法存储状态。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-110">State can be stored using several approaches.</span></span> <span data-ttu-id="2dd9d-111">本主题稍后将对每个方法进行介绍。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-111">Each approach is described later in this topic.</span></span>

| <span data-ttu-id="2dd9d-112">存储方法</span><span class="sxs-lookup"><span data-stu-id="2dd9d-112">Storage approach</span></span> | <span data-ttu-id="2dd9d-113">存储机制</span><span class="sxs-lookup"><span data-stu-id="2dd9d-113">Storage mechanism</span></span> |
| ---------------- | ----------------- |
| <span data-ttu-id="2dd9d-114">[Cookie](#cookies)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-114">[Cookies](#cookies)</span></span> | <span data-ttu-id="2dd9d-115">HTTP cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-115">HTTP cookies.</span></span> <span data-ttu-id="2dd9d-116">可能包括使用服务器端应用代码存储的数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-116">May include data stored using server-side app code.</span></span> |
| [<span data-ttu-id="2dd9d-117">Session State</span><span class="sxs-lookup"><span data-stu-id="2dd9d-117">Session state</span></span>](#session-state) | <span data-ttu-id="2dd9d-118">HTTP cookie 和服务器端应用代码</span><span class="sxs-lookup"><span data-stu-id="2dd9d-118">HTTP cookies and server-side app code</span></span> |
| [<span data-ttu-id="2dd9d-119">TempData</span><span class="sxs-lookup"><span data-stu-id="2dd9d-119">TempData</span></span>](#tempdata) | <span data-ttu-id="2dd9d-120">HTTP cookie 或会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-120">HTTP cookies or session state</span></span> |
| [<span data-ttu-id="2dd9d-121">Query Strings</span><span class="sxs-lookup"><span data-stu-id="2dd9d-121">Query strings</span></span>](#query-strings) | <span data-ttu-id="2dd9d-122">HTTP 查询字符串</span><span class="sxs-lookup"><span data-stu-id="2dd9d-122">HTTP query strings</span></span> |
| [<span data-ttu-id="2dd9d-123">Hidden Fields</span><span class="sxs-lookup"><span data-stu-id="2dd9d-123">Hidden fields</span></span>](#hidden-fields) | <span data-ttu-id="2dd9d-124">HTTP 窗体字段</span><span class="sxs-lookup"><span data-stu-id="2dd9d-124">HTTP form fields</span></span> |
| [<span data-ttu-id="2dd9d-125">HttpContext.Items</span><span class="sxs-lookup"><span data-stu-id="2dd9d-125">HttpContext.Items</span></span>](#httpcontextitems) | <span data-ttu-id="2dd9d-126">服务器端应用代码</span><span class="sxs-lookup"><span data-stu-id="2dd9d-126">Server-side app code</span></span> |
| [<span data-ttu-id="2dd9d-127">Cache</span><span class="sxs-lookup"><span data-stu-id="2dd9d-127">Cache</span></span>](#cache) | <span data-ttu-id="2dd9d-128">服务器端应用代码</span><span class="sxs-lookup"><span data-stu-id="2dd9d-128">Server-side app code</span></span> |

## <a name="cookies"></a><span data-ttu-id="2dd9d-129">Cookies</span><span class="sxs-lookup"><span data-stu-id="2dd9d-129">Cookies</span></span>

<span data-ttu-id="2dd9d-130">Cookie 存储请求之间的数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-130">Cookies store data across requests.</span></span> <span data-ttu-id="2dd9d-131">因为 cookie 是随每个请求发送的，所以它们的大小应该保持在最低限度。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-131">Because cookies are sent with every request, their size should be kept to a minimum.</span></span> <span data-ttu-id="2dd9d-132">理想情况下，仅标识符应存储在 cookie 中，而数据则由应用存储。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-132">Ideally, only an identifier should be stored in a cookie with the data stored by the app.</span></span> <span data-ttu-id="2dd9d-133">大多数浏览器 cookie 大小限制为 4096 个字节。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-133">Most browsers restrict cookie size to 4096 bytes.</span></span> <span data-ttu-id="2dd9d-134">每个域仅有有限数量的 cookie 可用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-134">Only a limited number of cookies are available for each domain.</span></span>

<span data-ttu-id="2dd9d-135">由于 cookie 易被篡改，因此它们必须由服务器进行验证。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-135">Because cookies are subject to tampering, they must be validated by the app.</span></span> <span data-ttu-id="2dd9d-136">客户端上的 Cookie 可能被用户删除或者过期。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-136">Cookies can be deleted by users and expire on clients.</span></span> <span data-ttu-id="2dd9d-137">但是，cookie 通常是客户端上最持久的数据暂留形式。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-137">However, cookies are generally the most durable form of data persistence on the client.</span></span>

<span data-ttu-id="2dd9d-138">Cookie 通常用于个性化设置，其中的内容是为已知用户定制的。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-138">Cookies are often used for personalization, where content is customized for a known user.</span></span> <span data-ttu-id="2dd9d-139">大多数情况下，仅标识用户，但不对其进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-139">The user is only identified and not authenticated in most cases.</span></span> <span data-ttu-id="2dd9d-140">cookie 可以存储用户名、帐户名或唯一的用户 ID（例如 GUID）。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-140">The cookie can store the user's name, account name, or unique user ID such as a GUID.</span></span> <span data-ttu-id="2dd9d-141">cookie 可用于访问用户的个性化设置，例如首选的网站背景色。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-141">The cookie can be used to access the user's personalized settings, such as their preferred website background color.</span></span>

<span data-ttu-id="2dd9d-142">发布 cookie 和处理隐私问题时，请参阅[欧盟一般数据保护条例 (GDPR)](https://ec.europa.eu/info/law/law-topic/data-protection)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-142">See the [European Union General Data Protection Regulations (GDPR)](https://ec.europa.eu/info/law/law-topic/data-protection) when issuing cookies and dealing with privacy concerns.</span></span> <span data-ttu-id="2dd9d-143">有关详细信息，请参阅 [ASP.NET Core 中的一般数据保护条例 (GDPR) 支持](xref:security/gdpr)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-143">For more information, see [General Data Protection Regulation (GDPR) support in ASP.NET Core](xref:security/gdpr).</span></span>

## <a name="session-state"></a><span data-ttu-id="2dd9d-144">会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-144">Session state</span></span>

<span data-ttu-id="2dd9d-145">会话状态是在用户浏览 Web 应用时用来存储用户数据的 ASP.NET Core 方案。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-145">Session state is an ASP.NET Core scenario for storage of user data while the user browses a web app.</span></span> <span data-ttu-id="2dd9d-146">会话状态使用应用维护的存储来保存客户端所有请求的数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-146">Session state uses a store maintained by the app to persist data across requests from a client.</span></span> <span data-ttu-id="2dd9d-147">会话数据由缓存提供支持，并被视为临时数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-147">The session data is backed by a cache and considered ephemeral data.</span></span> <span data-ttu-id="2dd9d-148">站点应在没有会话数据的情况下继续运行。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-148">The site should continue to function without the session data.</span></span> <span data-ttu-id="2dd9d-149">关键应用程序数据应存储在用户数据库中，并仅作为性能优化缓存在会话中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-149">Critical application data should be stored in the user database and cached in session only as a performance optimization.</span></span>

<span data-ttu-id="2dd9d-150">[SignalR](xref:signalr/index) 应用不支持会话，因为 [SignalR 中心](xref:signalr/hubs)可能独立于 HTTP 上下文执行。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-150">Session isn't supported in [SignalR](xref:signalr/index) apps because a [SignalR Hub](xref:signalr/hubs) may execute independent of an HTTP context.</span></span> <span data-ttu-id="2dd9d-151">例如，当中心打开的长轮询请求超出请求的 HTTP 上下文的生存期时，可能发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-151">For example, this can occur when a long polling request is held open by a hub beyond the lifetime of the request's HTTP context.</span></span>

<span data-ttu-id="2dd9d-152">ASP.NET Core 通过向客户端提供包含会话 ID 的 cookie 来维护会话状态。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-152">ASP.NET Core maintains session state by providing a cookie to the client that contains a session ID.</span></span> <span data-ttu-id="2dd9d-153">cookie 会话 ID：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-153">The cookie session ID:</span></span>

* <span data-ttu-id="2dd9d-154">会随每个请求发送到应用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-154">Is sent to the app with each request.</span></span>
* <span data-ttu-id="2dd9d-155">由应用用于提取会话数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-155">Is used by the app to fetch the session data.</span></span>

<span data-ttu-id="2dd9d-156">会话状态具有以下行为：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-156">Session state exhibits the following behaviors:</span></span>

* <span data-ttu-id="2dd9d-157">会话 cookie 特定于浏览器。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-157">The session cookie is specific to the browser.</span></span> <span data-ttu-id="2dd9d-158">会话不会跨浏览器进行共享。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-158">Sessions aren't shared across browsers.</span></span>
* <span data-ttu-id="2dd9d-159">浏览器会话结束时删除会话 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-159">Session cookies are deleted when the browser session ends.</span></span>
* <span data-ttu-id="2dd9d-160">如果收到过期的会话 cookie，则创建使用相同会话 cookie 的新会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-160">If a cookie is received for an expired session, a new session is created that uses the same session cookie.</span></span>
* <span data-ttu-id="2dd9d-161">不会保留空会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-161">Empty sessions aren't retained.</span></span> <span data-ttu-id="2dd9d-162">会话中必须设置了至少一个值以保存所有请求的会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-162">The session must have at least one value set to persist the session across requests.</span></span> <span data-ttu-id="2dd9d-163">会话未保留时，为每个新的请求生成新会话 ID。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-163">When a session isn't retained, a new session ID is generated for each new request.</span></span>
* <span data-ttu-id="2dd9d-164">应用在上次请求后保留会话的时间有限。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-164">The app retains a session for a limited time after the last request.</span></span> <span data-ttu-id="2dd9d-165">应用设置会话超时，或者使用 20 分钟的默认值。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-165">The app either sets the session timeout or uses the default value of 20 minutes.</span></span> <span data-ttu-id="2dd9d-166">在以下情况下，会话状态适合存储用户数据：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-166">Session state is ideal for storing user data:</span></span>
  * <span data-ttu-id="2dd9d-167">特定于某个特定会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-167">That's specific to a particular session.</span></span>
  * <span data-ttu-id="2dd9d-168">数据不需要跨会话永久存储。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-168">Where the data doesn't require permanent storage across sessions.</span></span>
* <span data-ttu-id="2dd9d-169">会话数据在调用 <xref:Microsoft.AspNetCore.Http.ISession.Clear%2A?displayProperty=nameWithType> 实现或会话到期时删除。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-169">Session data is deleted either when the <xref:Microsoft.AspNetCore.Http.ISession.Clear%2A?displayProperty=nameWithType> implementation is called or when the session expires.</span></span>
* <span data-ttu-id="2dd9d-170">没有默认机制告知客户端浏览器已关闭或者客户端上的会话 cookie 被删除或过期的应用代码。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-170">There's no default mechanism to inform app code that a client browser has been closed or when the session cookie is deleted or expired on the client.</span></span>
* <span data-ttu-id="2dd9d-171">默认情况下，会话状态 cookie 不标记为“基本”。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-171">Session state cookies aren't marked essential by default.</span></span> <span data-ttu-id="2dd9d-172">除非站点访问者允许跟踪，否则会话状态不起作用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-172">Session state isn't functional unless tracking is permitted by the site visitor.</span></span> <span data-ttu-id="2dd9d-173">有关详细信息，请参阅 <xref:security/gdpr#tempdata-provider-and-session-state-cookies-arent-essential>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-173">For more information, see <xref:security/gdpr#tempdata-provider-and-session-state-cookies-arent-essential>.</span></span>

> [!WARNING]
> <span data-ttu-id="2dd9d-174">请勿将敏感数据存储在会话状态中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-174">Don't store sensitive data in session state.</span></span> <span data-ttu-id="2dd9d-175">用户可能不会关闭浏览器或清除会话 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-175">The user might not close the browser and clear the session cookie.</span></span> <span data-ttu-id="2dd9d-176">某些浏览器会保留浏览器窗口之间的有效会话 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-176">Some browsers maintain valid session cookies across browser windows.</span></span> <span data-ttu-id="2dd9d-177">会话可能不限于单个用户。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-177">A session might not be restricted to a single user.</span></span> <span data-ttu-id="2dd9d-178">下一个用户可能继续使用同一会话 cookie 浏览应用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-178">The next user might continue to browse the app with the same session cookie.</span></span>

<span data-ttu-id="2dd9d-179">内存中缓存提供程序在应用驻留的服务器内存中存储会话数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-179">The in-memory cache provider stores session data in the memory of the server where the app resides.</span></span> <span data-ttu-id="2dd9d-180">在服务器场方案中：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-180">In a server farm scenario:</span></span>

* <span data-ttu-id="2dd9d-181">使用粘性会话将每个会话加入到单独服务器上的特定应用实例。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-181">Use *sticky sessions* to tie each session to a specific app instance on an individual server.</span></span> <span data-ttu-id="2dd9d-182">默认情况下，[Azure 应用服务](https://azure.microsoft.com/services/app-service/)使用[应用程序请求路由 (ARR)](/iis/extensions/planning-for-arr/using-the-application-request-routing-module) 强制实施粘性会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-182">[Azure App Service](https://azure.microsoft.com/services/app-service/) uses [Application Request Routing (ARR)](/iis/extensions/planning-for-arr/using-the-application-request-routing-module) to enforce sticky sessions by default.</span></span> <span data-ttu-id="2dd9d-183">然而，粘性会话可能会影响可伸缩性，并使 Web 应用更新变得复杂。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-183">However, sticky sessions can affect scalability and complicate web app updates.</span></span> <span data-ttu-id="2dd9d-184">更好的方法是使用 Redis 或 SQL Server 分布式缓存，它们不需要粘性会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-184">A better approach is to use a Redis or SQL Server distributed cache, which doesn't require sticky sessions.</span></span> <span data-ttu-id="2dd9d-185">有关详细信息，请参阅 <xref:performance/caching/distributed>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-185">For more information, see <xref:performance/caching/distributed>.</span></span>
* <span data-ttu-id="2dd9d-186">会话 cookie 通过 <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> 进行加密。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-186">The session cookie is encrypted via <xref:Microsoft.AspNetCore.DataProtection.IDataProtector>.</span></span> <span data-ttu-id="2dd9d-187">必须正确配置数据保护，以在每台计算机上读取会话 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-187">Data Protection must be properly configured to read session cookies on each machine.</span></span> <span data-ttu-id="2dd9d-188">有关详细信息，请参阅 <xref:security/data-protection/introduction> 和[密钥存储提供程序](xref:security/data-protection/implementation/key-storage-providers)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-188">For more information, see <xref:security/data-protection/introduction> and [Key storage providers](xref:security/data-protection/implementation/key-storage-providers).</span></span>

### <a name="configure-session-state"></a><span data-ttu-id="2dd9d-189">配置会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-189">Configure session state</span></span>

<span data-ttu-id="2dd9d-190">[Microsoft.AspNetCore.Session](https://www.nuget.org/packages/Microsoft.AspNetCore.Session/) 包：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-190">The [Microsoft.AspNetCore.Session](https://www.nuget.org/packages/Microsoft.AspNetCore.Session/) package:</span></span>

* <span data-ttu-id="2dd9d-191">由框架隐式包含。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-191">Is included implicitly by the framework.</span></span>
* <span data-ttu-id="2dd9d-192">提供用于管理会话状态的中间件。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-192">Provides middleware for managing session state.</span></span>

<span data-ttu-id="2dd9d-193">若要启用会话中间件，`Startup` 必须包含：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-193">To enable the session middleware, `Startup` must contain:</span></span>

* <span data-ttu-id="2dd9d-194">任何 <xref:Microsoft.Extensions.Caching.Distributed.IDistributedCache> 内存缓存。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-194">Any of the <xref:Microsoft.Extensions.Caching.Distributed.IDistributedCache> memory caches.</span></span> <span data-ttu-id="2dd9d-195">`IDistributedCache` 实现用作会话后备存储。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-195">The `IDistributedCache` implementation is used as a backing store for session.</span></span> <span data-ttu-id="2dd9d-196">有关详细信息，请参阅 <xref:performance/caching/distributed>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-196">For more information, see <xref:performance/caching/distributed>.</span></span>
* <span data-ttu-id="2dd9d-197">对 `ConfigureServices` 中 <xref:Microsoft.Extensions.DependencyInjection.SessionServiceCollectionExtensions.AddSession%2A> 的调用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-197">A call to <xref:Microsoft.Extensions.DependencyInjection.SessionServiceCollectionExtensions.AddSession%2A> in `ConfigureServices`.</span></span>
* <span data-ttu-id="2dd9d-198">对 `Configure` 中 <xref:Microsoft.AspNetCore.Builder.SessionMiddlewareExtensions.UseSession%2A> 的调用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-198">A call to <xref:Microsoft.AspNetCore.Builder.SessionMiddlewareExtensions.UseSession%2A> in `Configure`.</span></span>

<span data-ttu-id="2dd9d-199">以下代码演示如何使用 `IDistributedCache` 的默认内存中实现设置内存中会话提供程序：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-199">The following code shows how to set up the in-memory session provider with a default in-memory implementation of `IDistributedCache`:</span></span>

[!code-csharp[](app-state/samples/3.x/SessionSample/Startup4.cs?name=snippet1&highlight=12-19,45)]

<span data-ttu-id="2dd9d-200">前面的代码设置较短的超时来简化测试。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-200">The preceding code sets a short timeout to simplify testing.</span></span>

<span data-ttu-id="2dd9d-201">中间件的顺序很重要。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-201">The order of middleware is important.</span></span>  <span data-ttu-id="2dd9d-202">在 `UseRouting` 之后和 `UseEndpoints` 之前调用 `UseSession`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-202">Call `UseSession` after `UseRouting` and before `UseEndpoints`.</span></span> <span data-ttu-id="2dd9d-203">请参阅[中间件排序](xref:fundamentals/middleware/index#order)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-203">See [Middleware Ordering](xref:fundamentals/middleware/index#order).</span></span>

<span data-ttu-id="2dd9d-204">配置会话状态后，[HttpContext.Session](xref:Microsoft.AspNetCore.Http.HttpContext.Session) 可用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-204">[HttpContext.Session](xref:Microsoft.AspNetCore.Http.HttpContext.Session) is available after session state is configured.</span></span>

<span data-ttu-id="2dd9d-205">调用 `UseSession` 以前无法访问 `HttpContext.Session`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-205">`HttpContext.Session` can't be accessed before `UseSession` has been called.</span></span>

<span data-ttu-id="2dd9d-206">在应用已经开始写入到响应流之后，不能创建有新会话 cookie 的新会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-206">A new session with a new session cookie can't be created after the app has begun writing to the response stream.</span></span> <span data-ttu-id="2dd9d-207">此异常记录在 Web 服务器日志中但不显示在浏览器中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-207">The exception is recorded in the web server log and not displayed in the browser.</span></span>

### <a name="load-session-state-asynchronously"></a><span data-ttu-id="2dd9d-208">以异步方式加载会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-208">Load session state asynchronously</span></span>

<span data-ttu-id="2dd9d-209">只有当 <xref:Microsoft.AspNetCore.Http.ISession.LoadAsync%2A?displayProperty=nameWithType> 方法是先于 <xref:Microsoft.AspNetCore.Http.ISession.TryGetValue%2A>、<xref:Microsoft.AspNetCore.Http.ISession.Set%2A> 或 <xref:Microsoft.AspNetCore.Http.ISession.Remove%2A> 方法显式调用时，ASP.NET Core 中的默认会话提供程序才会从基础 <xref:Microsoft.Extensions.Caching.Distributed.IDistributedCache> 后备存储中异步加载会话记录。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-209">The default session provider in ASP.NET Core loads session records from the underlying <xref:Microsoft.Extensions.Caching.Distributed.IDistributedCache> backing store asynchronously only if the <xref:Microsoft.AspNetCore.Http.ISession.LoadAsync%2A?displayProperty=nameWithType> method is explicitly called before the <xref:Microsoft.AspNetCore.Http.ISession.TryGetValue%2A>, <xref:Microsoft.AspNetCore.Http.ISession.Set%2A>, or <xref:Microsoft.AspNetCore.Http.ISession.Remove%2A> methods.</span></span> <span data-ttu-id="2dd9d-210">如果未先调用 `LoadAsync`，则会同步加载基础会话记录，这可能对性能产生大规模影响。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-210">If `LoadAsync` isn't called first, the underlying session record is loaded synchronously, which can incur a performance penalty at scale.</span></span>

<span data-ttu-id="2dd9d-211">若要让应用强制执行此模式，请使用在 `LoadAsync` 方法没有先于 `TryGetValue`、`Set` 或 `Remove` 调用时抛出异常的版本来包装 <xref:Microsoft.AspNetCore.Session.DistributedSessionStore> 和 <xref:Microsoft.AspNetCore.Session.DistributedSession> 实现。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-211">To have apps enforce this pattern, wrap the <xref:Microsoft.AspNetCore.Session.DistributedSessionStore> and <xref:Microsoft.AspNetCore.Session.DistributedSession> implementations with versions that throw an exception if the `LoadAsync` method isn't called before `TryGetValue`, `Set`, or `Remove`.</span></span> <span data-ttu-id="2dd9d-212">在服务容器中注册的已包装的版本。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-212">Register the wrapped versions in the services container.</span></span>

### <a name="session-options"></a><span data-ttu-id="2dd9d-213">会话选项</span><span class="sxs-lookup"><span data-stu-id="2dd9d-213">Session options</span></span>

<span data-ttu-id="2dd9d-214">若要重写会话默认值，请使用 <xref:Microsoft.AspNetCore.Builder.SessionOptions>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-214">To override session defaults, use <xref:Microsoft.AspNetCore.Builder.SessionOptions>.</span></span>

| <span data-ttu-id="2dd9d-215">选项</span><span class="sxs-lookup"><span data-stu-id="2dd9d-215">Option</span></span> | <span data-ttu-id="2dd9d-216">描述</span><span class="sxs-lookup"><span data-stu-id="2dd9d-216">Description</span></span> |
| ------ | ----------- |
| <xref:Microsoft.AspNetCore.Builder.SessionOptions.Cookie> | <span data-ttu-id="2dd9d-217">确定用于创建 cookie 的设置。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-217">Determines the settings used to create the cookie.</span></span> <span data-ttu-id="2dd9d-218"><xref:Microsoft.AspNetCore.Http.CookieBuilder.Name> 默认为 <xref:Microsoft.AspNetCore.Session.SessionDefaults.CookieName?displayProperty=nameWithType> (`.AspNetCore.Session`)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-218"><xref:Microsoft.AspNetCore.Http.CookieBuilder.Name> defaults to <xref:Microsoft.AspNetCore.Session.SessionDefaults.CookieName?displayProperty=nameWithType> (`.AspNetCore.Session`).</span></span> <span data-ttu-id="2dd9d-219"><xref:Microsoft.AspNetCore.Http.CookieBuilder.Path> 默认为 <xref:Microsoft.AspNetCore.Session.SessionDefaults.CookiePath?displayProperty=nameWithType> (`/`)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-219"><xref:Microsoft.AspNetCore.Http.CookieBuilder.Path> defaults to <xref:Microsoft.AspNetCore.Session.SessionDefaults.CookiePath?displayProperty=nameWithType> (`/`).</span></span> <span data-ttu-id="2dd9d-220"><xref:Microsoft.AspNetCore.Http.CookieBuilder.SameSite> 默认为 <xref:Microsoft.AspNetCore.Http.SameSiteMode.Lax?displayProperty=nameWithType> (`1`)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-220"><xref:Microsoft.AspNetCore.Http.CookieBuilder.SameSite> defaults to <xref:Microsoft.AspNetCore.Http.SameSiteMode.Lax?displayProperty=nameWithType> (`1`).</span></span> <span data-ttu-id="2dd9d-221"><xref:Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly> 默认为 `true`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-221"><xref:Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly> defaults to `true`.</span></span> <span data-ttu-id="2dd9d-222"><xref:Microsoft.AspNetCore.Http.CookieBuilder.IsEssential> 默认为 `false`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-222"><xref:Microsoft.AspNetCore.Http.CookieBuilder.IsEssential> defaults to `false`.</span></span> |
| <xref:Microsoft.AspNetCore.Builder.SessionOptions.IdleTimeout> | <span data-ttu-id="2dd9d-223">`IdleTimeout` 显示放弃其内容前，内容可以空闲多长时间。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-223">The `IdleTimeout` indicates how long the session can be idle before its contents are abandoned.</span></span> <span data-ttu-id="2dd9d-224">每个会话访问都会重置超时。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-224">Each session access resets the timeout.</span></span> <span data-ttu-id="2dd9d-225">此设置仅适用于会话内容，不适用于 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-225">This setting only applies to the content of the session, not the cookie.</span></span> <span data-ttu-id="2dd9d-226">默认为 20 分钟。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-226">The default is 20 minutes.</span></span> |
| <xref:Microsoft.AspNetCore.Builder.SessionOptions.IOTimeout> | <span data-ttu-id="2dd9d-227">允许从存储加载会话或者将其提交回存储的最大时长。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-227">The maximum amount of time allowed to load a session from the store or to commit it back to the store.</span></span> <span data-ttu-id="2dd9d-228">此设置可能仅适用于异步操作。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-228">This setting may only apply to asynchronous operations.</span></span> <span data-ttu-id="2dd9d-229">可以使用 <xref:System.Threading.Timeout.InfiniteTimeSpan> 来禁用此超时。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-229">This timeout can be disabled using <xref:System.Threading.Timeout.InfiniteTimeSpan>.</span></span> <span data-ttu-id="2dd9d-230">默认值为 1 分钟。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-230">The default is 1 minute.</span></span> |

<span data-ttu-id="2dd9d-231">会话使用 cookie 跟踪和标识来自单个浏览器的请求。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-231">Session uses a cookie to track and identify requests from a single browser.</span></span> <span data-ttu-id="2dd9d-232">默认情况下，此 cookie 名为 `.AspNetCore.Session`，并使用路径 `/`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-232">By default, this cookie is named `.AspNetCore.Session`, and it uses a path of `/`.</span></span> <span data-ttu-id="2dd9d-233">由于 cookie 默认值没有指定域，因此页面上的客户端脚本无法使用它（因为 <xref:Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly> 默认为 `true`）。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-233">Because the cookie default doesn't specify a domain, it isn't made available to the client-side script on the page (because <xref:Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly> defaults to `true`).</span></span>

<span data-ttu-id="2dd9d-234">若要重写 cookie 会话默认值，请使用 <xref:Microsoft.AspNetCore.Builder.SessionOptions>：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-234">To override cookie session defaults, use <xref:Microsoft.AspNetCore.Builder.SessionOptions>:</span></span>

[!code-csharp[](app-state/samples/3.x/SessionSample/Startup2.cs?name=snippet1&highlight=5-10)]

<span data-ttu-id="2dd9d-235">应用使用 <xref:Microsoft.AspNetCore.Builder.SessionOptions.IdleTimeout> 属性来确定在会话空闲多长时间后它在服务器缓存中的内容就会被放弃。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-235">The app uses the <xref:Microsoft.AspNetCore.Builder.SessionOptions.IdleTimeout> property to determine how long a session can be idle before its contents in the server's cache are abandoned.</span></span> <span data-ttu-id="2dd9d-236">此属性独立于 cookie 到期时间。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-236">This property is independent of the cookie expiration.</span></span> <span data-ttu-id="2dd9d-237">通过[会话中间件](xref:Microsoft.AspNetCore.Session.SessionMiddleware)传递的每个请求都会重置超时。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-237">Each request that passes through the [Session Middleware](xref:Microsoft.AspNetCore.Session.SessionMiddleware) resets the timeout.</span></span>

<span data-ttu-id="2dd9d-238">会话状态为“非锁定”。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-238">Session state is *non-locking*.</span></span> <span data-ttu-id="2dd9d-239">如果两个请求同时尝试修改同一会话的内容，则后一个请求替代前一个请求。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-239">If two requests simultaneously attempt to modify the contents of a session, the last request overrides the first.</span></span> <span data-ttu-id="2dd9d-240">`Session` 是作为一个连贯会话实现的，这意味着所有内容都存储在一起。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-240">`Session` is implemented as a *coherent session*, which means that all the contents are stored together.</span></span> <span data-ttu-id="2dd9d-241">两个请求试图修改不同的会话值时，后一个请求可能替代前一个做出的会话更改。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-241">When two requests seek to modify different session values, the last request may override session changes made by the first.</span></span>

### <a name="set-and-get-session-values"></a><span data-ttu-id="2dd9d-242">设置和获取会话值</span><span class="sxs-lookup"><span data-stu-id="2dd9d-242">Set and get Session values</span></span>

<span data-ttu-id="2dd9d-243">会话状态是通过 Razor Pages <xref:Microsoft.AspNetCore.Mvc.RazorPages.PageModel> 类或包含 <xref:Microsoft.AspNetCore.Http.HttpContext.Session?displayProperty=nameWithType> 的 MVC <xref:Microsoft.AspNetCore.Mvc.Controller> 类进行访问。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-243">Session state is accessed from a Razor Pages <xref:Microsoft.AspNetCore.Mvc.RazorPages.PageModel> class or MVC <xref:Microsoft.AspNetCore.Mvc.Controller> class with <xref:Microsoft.AspNetCore.Http.HttpContext.Session?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2dd9d-244">此属性是 <xref:Microsoft.AspNetCore.Http.ISession> 实现。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-244">This property is an <xref:Microsoft.AspNetCore.Http.ISession> implementation.</span></span>

<span data-ttu-id="2dd9d-245">`ISession` 实现提供用于设置和检索整数和字符串值的若干扩展方法。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-245">The `ISession` implementation provides several extension methods to set and retrieve integer and string values.</span></span> <span data-ttu-id="2dd9d-246">扩展方法位于 <xref:Microsoft.AspNetCore.Http> 命名空间中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-246">The extension methods are in the <xref:Microsoft.AspNetCore.Http> namespace.</span></span>

<span data-ttu-id="2dd9d-247">`ISession` 扩展方法：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-247">`ISession` extension methods:</span></span>

* [<span data-ttu-id="2dd9d-248">Get(ISession, String)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-248">Get(ISession, String)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.Get%2A)
* [<span data-ttu-id="2dd9d-249">GetInt32(ISession, String)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-249">GetInt32(ISession, String)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.GetInt32%2A)
* [<span data-ttu-id="2dd9d-250">GetString(ISession, String)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-250">GetString(ISession, String)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.GetString%2A)
* [<span data-ttu-id="2dd9d-251">SetInt32(ISession, String, Int32)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-251">SetInt32(ISession, String, Int32)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.SetInt32%2A)
* [<span data-ttu-id="2dd9d-252">SetString(ISession, String, String)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-252">SetString(ISession, String, String)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.SetString%2A)

<span data-ttu-id="2dd9d-253">以下示例在 Razor Pages 页中检索 `IndexModel.SessionKeyName` 键（示例应用中的 `_Name`）的会话值：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-253">The following example retrieves the session value for the `IndexModel.SessionKeyName` key (`_Name` in the sample app) in a Razor Pages page:</span></span>

```csharp
@page
@using Microsoft.AspNetCore.Http
@model IndexModel

...

Name: @HttpContext.Session.GetString(IndexModel.SessionKeyName)
```

<span data-ttu-id="2dd9d-254">以下示例显示如何设置和获取整数和字符串：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-254">The following example shows how to set and get an integer and a string:</span></span>

[!code-csharp[](app-state/samples/3.x/SessionSample/Pages/Index.cshtml.cs?name=snippet1&highlight=18-19,22-23)]

<span data-ttu-id="2dd9d-255">必须对所有会话数据进行序列化以启用分布式缓存方案，即使是在使用内存中缓存的时候。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-255">All session data must be serialized to enable a distributed cache scenario, even when using the in-memory cache.</span></span> <span data-ttu-id="2dd9d-256">字符串和整数序列化程序是由 <xref:Microsoft.AspNetCore.Http.ISession> 的扩展方法提供。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-256">String and integer serializers are provided by the extension methods of <xref:Microsoft.AspNetCore.Http.ISession>.</span></span> <span data-ttu-id="2dd9d-257">用户必须使用另一种机制（例如 JSON）序列化复杂类型。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-257">Complex types must be serialized by the user using another mechanism, such as JSON.</span></span>

<span data-ttu-id="2dd9d-258">使用以下示例代码序列化对象：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-258">Use the following sample code to serialize objects:</span></span>

[!code-csharp[](app-state/samples/3.x/SessionSample/Extensions/SessionExtensions.cs?name=snippet1)]

<span data-ttu-id="2dd9d-259">以下示例演示如何使用 `SessionExtensions` 类设置和获取可序列化的对象：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-259">The following example shows how to set and get a serializable object with the `SessionExtensions` class:</span></span>

[!code-csharp[](app-state/samples/3.x/SessionSample/Pages/Index.cshtml.cs?name=snippet2)]

## <a name="tempdata"></a><span data-ttu-id="2dd9d-260">TempData</span><span class="sxs-lookup"><span data-stu-id="2dd9d-260">TempData</span></span>

<span data-ttu-id="2dd9d-261">ASP.NET Core 公开 Razor Pages [TempData](xref:Microsoft.AspNetCore.Mvc.RazorPages.PageModel.TempData) 或控制器 <xref:Microsoft.AspNetCore.Mvc.Controller.TempData>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-261">ASP.NET Core exposes the Razor Pages [TempData](xref:Microsoft.AspNetCore.Mvc.RazorPages.PageModel.TempData) or Controller <xref:Microsoft.AspNetCore.Mvc.Controller.TempData>.</span></span> <span data-ttu-id="2dd9d-262">在另一个请求读取数据之前，此属性将读取此数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-262">This property stores data until it's read in another request.</span></span> <span data-ttu-id="2dd9d-263">[Keep(String)](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Keep*) 和 [Peek(string)](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Peek*) 方法可用于检查数据，而无需在请求结束时删除。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-263">The [Keep(String)](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Keep*) and [Peek(string)](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Peek*) methods can be used to examine the data without deletion at the end of the request.</span></span> <span data-ttu-id="2dd9d-264">[Keep](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Keep*) 将标记字典中的所有项以进行保留。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-264">[Keep](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Keep*) marks all items in the dictionary for retention.</span></span> <span data-ttu-id="2dd9d-265">`TempData` 为：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-265">`TempData` is:</span></span>

* <span data-ttu-id="2dd9d-266">在多个请求需要数据的情况下对重定向很有用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-266">Useful for redirection when data is required for more than a single request.</span></span>
* <span data-ttu-id="2dd9d-267">使用 cookie 或会话状态通过 `TempData` 提供程序进行实现。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-267">Implemented by `TempData` providers using either cookies or session state.</span></span>

## <a name="tempdata-samples"></a><span data-ttu-id="2dd9d-268">TempData 示例</span><span class="sxs-lookup"><span data-stu-id="2dd9d-268">TempData samples</span></span>

<span data-ttu-id="2dd9d-269">考虑创建客户的以下页面：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-269">Consider the following page that creates a customer:</span></span>

[!code-csharp[](app-state/3.0samples/RazorPagesContacts/Pages/Customers/Create.cshtml.cs?name=snippet&highlight=15-16,30)]

<span data-ttu-id="2dd9d-270">以下页面显示 `TempData["Message"]`：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-270">The following page displays `TempData["Message"]`:</span></span>

[!code-cshtml[](app-state/3.0samples/RazorPagesContacts/Pages/Customers/IndexPeek.cshtml?range=1-14)]

<span data-ttu-id="2dd9d-271">在前面的标记中，在请求结束时，不会删除 `TempData["Message"]`，因为正在使用 `Peek`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-271">In the preceding markup, at the end of the request, `TempData["Message"]` is **not** deleted because `Peek` is used.</span></span> <span data-ttu-id="2dd9d-272">刷新页面将显示 `TempData["Message"]` 的内容。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-272">Refreshing the page displays the contents of `TempData["Message"]`.</span></span>

<span data-ttu-id="2dd9d-273">以下标记类似于前面的代码，但使用 `Keep` 在请求结束时保留数据：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-273">The following markup is similar to the preceding code, but uses `Keep` to preserve the data at the end of the request:</span></span>

[!code-cshtml[](app-state/3.0samples/RazorPagesContacts/Pages/Customers/IndexKeep.cshtml?range=1-14)]

<span data-ttu-id="2dd9d-274">在 IndexPeek 和 IndexKeep 页面之间导航不会删除 `TempData["Message"]`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-274">Navigating between the *IndexPeek* and *IndexKeep* pages won't delete `TempData["Message"]`.</span></span>

<span data-ttu-id="2dd9d-275">以下代码显示 `TempData["Message"]`，但请求结束时，将删除 `TempData["Message"]`：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-275">The following code displays `TempData["Message"]`, but at the end of the request, `TempData["Message"]` is deleted:</span></span>

[!code-cshtml[](app-state/3.0samples/RazorPagesContacts/Pages/Customers/Index.cshtml?range=1-14)]

### <a name="tempdata-providers"></a><span data-ttu-id="2dd9d-276">TempData 提供程序</span><span class="sxs-lookup"><span data-stu-id="2dd9d-276">TempData providers</span></span>

<span data-ttu-id="2dd9d-277">默认情况下使用基于 cookie 的 TempData 提供程序将 TempData 存储于 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-277">The cookie-based TempData provider is used by default to store TempData in cookies.</span></span>

<span data-ttu-id="2dd9d-278">cookie 数据是先使用 <xref:Microsoft.AspNetCore.DataProtection.IDataProtector>（用 <xref:Microsoft.AspNetCore.WebUtilities.Base64UrlTextEncoder> 编码）进行加密，再进行区块处理。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-278">The cookie data is encrypted using <xref:Microsoft.AspNetCore.DataProtection.IDataProtector>, encoded with <xref:Microsoft.AspNetCore.WebUtilities.Base64UrlTextEncoder>, then chunked.</span></span> <span data-ttu-id="2dd9d-279">由于加密和分块，最大 cookie 大小小于 [4096 个字节](http://www.faqs.org/rfcs/rfc2965.html)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-279">The maximum cookie size is less than [4096 bytes](http://www.faqs.org/rfcs/rfc2965.html) due to encryption and chunking.</span></span> <span data-ttu-id="2dd9d-280">未压缩 cookie 数据，因为压缩加密的数据会导致安全问题，如 [CRIME](https://wikipedia.org/wiki/CRIME_(security_exploit)) 和 [BREACH](https://wikipedia.org/wiki/BREACH_(security_exploit)) 攻击。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-280">The cookie data isn't compressed because compressing encrypted data can lead to security problems such as the [CRIME](https://wikipedia.org/wiki/CRIME_(security_exploit)) and [BREACH](https://wikipedia.org/wiki/BREACH_(security_exploit)) attacks.</span></span> <span data-ttu-id="2dd9d-281">若要详细了解基于 cookie 的 TempData 提供程序，请参阅 <xref:Microsoft.AspNetCore.Mvc.ViewFeatures.CookieTempDataProvider>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-281">For more information on the cookie-based TempData provider, see <xref:Microsoft.AspNetCore.Mvc.ViewFeatures.CookieTempDataProvider>.</span></span>

### <a name="choose-a-tempdata-provider"></a><span data-ttu-id="2dd9d-282">选择 TempData 提供程序</span><span class="sxs-lookup"><span data-stu-id="2dd9d-282">Choose a TempData provider</span></span>

<span data-ttu-id="2dd9d-283">选择 TempData 提供程序涉及几个注意事项，例如：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-283">Choosing a TempData provider involves several considerations, such as:</span></span>

* <span data-ttu-id="2dd9d-284">应用是否已使用会话状态？</span><span class="sxs-lookup"><span data-stu-id="2dd9d-284">Does the app already use session state?</span></span> <span data-ttu-id="2dd9d-285">如果是，使用会话状态 TempData 提供程序对应用没有额外的成本（除了数据的大小）。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-285">If so, using the session state TempData provider has no additional cost to the app beyond the size of the data.</span></span>
* <span data-ttu-id="2dd9d-286">应用是否只对相对较小的数据量（最多 500 个字节）使用 TempData？</span><span class="sxs-lookup"><span data-stu-id="2dd9d-286">Does the app use TempData only sparingly for relatively small amounts of data, up to 500 bytes?</span></span> <span data-ttu-id="2dd9d-287">如果是，cookie TempData 提供程序将为每个携带 TempData 的请求增加较小的成本。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-287">If so, the cookie TempData provider adds a small cost to each request that carries TempData.</span></span> <span data-ttu-id="2dd9d-288">如果不是，会话状态 TempData 提供程序有助于在使用 TempData 前，避免在每个请求中来回切换大量数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-288">If not, the session state TempData provider can be beneficial to avoid round-tripping a large amount of data in each request until the TempData is consumed.</span></span>
* <span data-ttu-id="2dd9d-289">应用是否在多个服务器上的服务器场中运行？</span><span class="sxs-lookup"><span data-stu-id="2dd9d-289">Does the app run in a server farm on multiple servers?</span></span> <span data-ttu-id="2dd9d-290">如果是，无需其他任何配置，即可在数据保护外使用 cookie TempData 提供程序（请参阅 <xref:security/data-protection/introduction>和[密钥存储提供程序](xref:security/data-protection/implementation/key-storage-providers)）。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-290">If so, there's no additional configuration required to use the cookie TempData provider outside of Data Protection (see <xref:security/data-protection/introduction> and [Key storage providers](xref:security/data-protection/implementation/key-storage-providers)).</span></span>

<span data-ttu-id="2dd9d-291">大多数 Web 客户端（如 Web 浏览器）针对每个 cookie 的最大大小和 cookie 总数强制实施限制。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-291">Most web clients such as web browsers enforce limits on the maximum size of each cookie and the total number of cookies.</span></span> <span data-ttu-id="2dd9d-292">使用 cookie TempData 提供程序时，请验证应用未超过[这些限制](http://www.faqs.org/rfcs/rfc2965.html)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-292">When using the cookie TempData provider, verify the app won't exceed [these limits](http://www.faqs.org/rfcs/rfc2965.html).</span></span> <span data-ttu-id="2dd9d-293">考虑数据的总大小。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-293">Consider the total size of the data.</span></span> <span data-ttu-id="2dd9d-294">解释加密和分块导致的 cookie 大小增加。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-294">Account for increases in cookie size due to encryption and chunking.</span></span>

### <a name="configure-the-tempdata-provider"></a><span data-ttu-id="2dd9d-295">配置 TempData 提供程序</span><span class="sxs-lookup"><span data-stu-id="2dd9d-295">Configure the TempData provider</span></span>

<span data-ttu-id="2dd9d-296">默认情况下启用基于 cookie 的 TempData 提供程序。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-296">The cookie-based TempData provider is enabled by default.</span></span>

<span data-ttu-id="2dd9d-297">若要启用基于会话的 TempData 提供程序，请使用 <xref:Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcBuilderExtensions.AddSessionStateTempDataProvider%2A> 扩展方法。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-297">To enable the session-based TempData provider, use the <xref:Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcBuilderExtensions.AddSessionStateTempDataProvider%2A> extension method.</span></span> <span data-ttu-id="2dd9d-298">只需要调用 `AddSessionStateTempDataProvider`：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-298">Only one call to `AddSessionStateTempDataProvider` is required:</span></span>

[!code-csharp[](app-state/samples/3.x/SessionSample/Startup3.cs?name=snippet1&highlight=4,6,8,30)]

## <a name="query-strings"></a><span data-ttu-id="2dd9d-299">查询字符串</span><span class="sxs-lookup"><span data-stu-id="2dd9d-299">Query strings</span></span>

<span data-ttu-id="2dd9d-300">可以将有限的数据从一个请求传递到另一个请求，方法是将其添加到新请求的查询字符串中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-300">A limited amount of data can be passed from one request to another by adding it to the new request's query string.</span></span> <span data-ttu-id="2dd9d-301">这有利于以一种持久的方式捕获状态，这种方式允许通过电子邮件或社交网络共享嵌入式状态的链接。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-301">This is useful for capturing state in a persistent manner that allows links with embedded state to be shared through email or social networks.</span></span> <span data-ttu-id="2dd9d-302">由于 URL 查询字符串是公共的，因此请勿对敏感数据使用查询字符串。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-302">Because URL query strings are public, never use query strings for sensitive data.</span></span>

<span data-ttu-id="2dd9d-303">除了意外共享之外，在查询字符串中包含数据还会使应用遭受[跨站点请求伪造 (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)) 攻击。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-303">In addition to unintended sharing, including data in query strings can expose the app to [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)) attacks.</span></span> <span data-ttu-id="2dd9d-304">任何保留的会话状态必须防止 CSRF 攻击。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-304">Any preserved session state must protect against CSRF attacks.</span></span> <span data-ttu-id="2dd9d-305">有关详细信息，请参阅 <xref:security/anti-request-forgery>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-305">For more information, see <xref:security/anti-request-forgery>.</span></span>

## <a name="hidden-fields"></a><span data-ttu-id="2dd9d-306">隐藏字段</span><span class="sxs-lookup"><span data-stu-id="2dd9d-306">Hidden fields</span></span>

<span data-ttu-id="2dd9d-307">数据可以保存在隐藏的表单域中，并在下一个请求上回发。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-307">Data can be saved in hidden form fields and posted back on the next request.</span></span> <span data-ttu-id="2dd9d-308">这在多页窗体中很常见。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-308">This is common in multi-page forms.</span></span> <span data-ttu-id="2dd9d-309">由于客户端可能篡改数据，因此应用必须始终重新验证存储在隐藏字段中的数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-309">Because the client can potentially tamper with the data, the app must always revalidate the data stored in hidden fields.</span></span>

## <a name="httpcontextitems"></a><span data-ttu-id="2dd9d-310">HttpContext.Items</span><span class="sxs-lookup"><span data-stu-id="2dd9d-310">HttpContext.Items</span></span>

<span data-ttu-id="2dd9d-311"><xref:Microsoft.AspNetCore.Http.HttpContext.Items?displayProperty=nameWithType> 集合用于在处理单个请求时存储数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-311">The <xref:Microsoft.AspNetCore.Http.HttpContext.Items?displayProperty=nameWithType> collection is used to store data while processing a single request.</span></span> <span data-ttu-id="2dd9d-312">处理请求后，放弃集合的内容。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-312">The collection's contents are discarded after a request is processed.</span></span> <span data-ttu-id="2dd9d-313">通常使用 `Items` 集合允许组件或中间件在请求期间在不同时间点操作且没有直接传递参数的方法时进行通信。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-313">The `Items` collection is often used to allow components or middleware to communicate when they operate at different points in time during a request and have no direct way to pass parameters.</span></span>

<span data-ttu-id="2dd9d-314">在下面示例中，[中间件](xref:fundamentals/middleware/index)将 `isVerified` 添加到 `Items` 集合：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-314">In the following example, [middleware](xref:fundamentals/middleware/index) adds `isVerified` to the `Items` collection:</span></span>

[!code-csharp[](app-state/samples/3.x/SessionSample/Startup.cs?name=snippet1)]

<span data-ttu-id="2dd9d-315">对于只在单个应用中使用的中间件，固定 `string` 键是可以接受的。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-315">For middleware that's only used in a single app, fixed `string` keys are acceptable.</span></span> <span data-ttu-id="2dd9d-316">应用间共享的中间件应使用唯一的对象键以避免键冲突。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-316">Middleware shared between apps should use unique object keys to avoid key collisions.</span></span> <span data-ttu-id="2dd9d-317">以下示例演示如何使用中间件类中定义的唯一对象键：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-317">The following example shows how to use a unique object key defined in a middleware class:</span></span>

[!code-csharp[](app-state/samples/3.x/SessionSample/Middleware/HttpContextItemsMiddleware.cs?name=snippet1&highlight=4,13)]

<span data-ttu-id="2dd9d-318">其他代码可以使用通过中间件类公开的键访问存储在 `HttpContext.Items` 中的值：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-318">Other code can access the value stored in `HttpContext.Items` using the key exposed by the middleware class:</span></span>

[!code-csharp[](app-state/samples/3.x/SessionSample/Pages/Index.cshtml.cs?name=snippet3)]

<span data-ttu-id="2dd9d-319">此方法还有避免在代码中使用关键字符串的优势。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-319">This approach also has the advantage of eliminating the use of key strings in the code.</span></span>

## <a name="cache"></a><span data-ttu-id="2dd9d-320">缓存</span><span class="sxs-lookup"><span data-stu-id="2dd9d-320">Cache</span></span>

<span data-ttu-id="2dd9d-321">缓存是存储和检索数据的有效方法。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-321">Caching is an efficient way to store and retrieve data.</span></span> <span data-ttu-id="2dd9d-322">应用可以控制缓存项的生存期。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-322">The app can control the lifetime of cached items.</span></span> <span data-ttu-id="2dd9d-323">有关详细信息，请参阅 <xref:performance/caching/response>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-323">For more information, see <xref:performance/caching/response>.</span></span>

<span data-ttu-id="2dd9d-324">缓存数据未与特定请求、用户或会话相关联。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-324">Cached data isn't associated with a specific request, user, or session.</span></span> <span data-ttu-id="2dd9d-325">请不要缓存可能由其他用户请求检索的特定于用户的数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-325">**Do not cache user-specific data that may be retrieved by other user requests.**</span></span>

<span data-ttu-id="2dd9d-326">若要缓存应用程序范围内的数据，请参阅 <xref:performance/caching/memory>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-326">To cache application wide data, see <xref:performance/caching/memory>.</span></span>

## <a name="common-errors"></a><span data-ttu-id="2dd9d-327">常见错误</span><span class="sxs-lookup"><span data-stu-id="2dd9d-327">Common errors</span></span>

* <span data-ttu-id="2dd9d-328">“在尝试激活‘Microsoft.AspNetCore.Session.DistributedSessionStore’时无法为类型‘Microsoft.Extensions.Caching.Distributed.IDistributedCache’解析服务。”</span><span class="sxs-lookup"><span data-stu-id="2dd9d-328">"Unable to resolve service for type 'Microsoft.Extensions.Caching.Distributed.IDistributedCache' while attempting to activate 'Microsoft.AspNetCore.Session.DistributedSessionStore'."</span></span>

  <span data-ttu-id="2dd9d-329">这通常是由于不能配置至少一个 `IDistributedCache` 实现而造成的。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-329">This is typically caused by failing to configure at least one `IDistributedCache` implementation.</span></span> <span data-ttu-id="2dd9d-330">有关详细信息，请参阅 <xref:performance/caching/distributed> 和 <xref:performance/caching/memory>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-330">For more information, see <xref:performance/caching/distributed> and <xref:performance/caching/memory>.</span></span>

<span data-ttu-id="2dd9d-331">如果会话中间件无法保留会话：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-331">If the session middleware fails to persist a session:</span></span>

* <span data-ttu-id="2dd9d-332">中间件记录异常而请求继续正常进行。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-332">The middleware logs the exception and the request continues normally.</span></span>
* <span data-ttu-id="2dd9d-333">这会导致不可预知的行为。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-333">This leads to unpredictable behavior.</span></span>

<span data-ttu-id="2dd9d-334">如果后备存储不可用，则会话中间件可能无法保留会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-334">The session middleware can fail to persist a session if the backing store isn't available.</span></span> <span data-ttu-id="2dd9d-335">例如，用户将购物车存储在会话中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-335">For example, a user stores a shopping cart in session.</span></span> <span data-ttu-id="2dd9d-336">用户将商品添加到购物车，但提交失败。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-336">The user adds an item to the cart but the commit fails.</span></span> <span data-ttu-id="2dd9d-337">应用不知道有此失败，因此它向用户报告商品已添加到购物车，但事实并非如此。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-337">The app doesn't know about the failure so it reports to the user that the item was added to their cart, which isn't true.</span></span>

<span data-ttu-id="2dd9d-338">检查此类错误的建议方法是完成将应用写入到该会话后，调用 `await feature.Session.CommitAsync`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-338">The recommended approach to check for errors is to call `await feature.Session.CommitAsync` when the app is done writing to the session.</span></span> <span data-ttu-id="2dd9d-339">如果后备存储不可用，则 <xref:Microsoft.AspNetCore.Http.ISession.CommitAsync*> 引发异常。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-339"><xref:Microsoft.AspNetCore.Http.ISession.CommitAsync*> throws an exception if the backing store is unavailable.</span></span> <span data-ttu-id="2dd9d-340">如果 `CommitAsync` 失败，应用可以处理异常。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-340">If `CommitAsync` fails, the app can process the exception.</span></span> <span data-ttu-id="2dd9d-341">在与数据存储不可用的相同的条件下，<xref:Microsoft.AspNetCore.Http.ISession.LoadAsync*> 引发异常。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-341"><xref:Microsoft.AspNetCore.Http.ISession.LoadAsync*> throws under the same conditions when the data store is unavailable.</span></span>
  
## <a name="signalr-and-session-state"></a><span data-ttu-id="2dd9d-342">SignalR 和会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-342">SignalR and session state</span></span>

<span data-ttu-id="2dd9d-343">SignalR 应用不应使用会话状态来存储信息。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-343">SignalR apps should not use session state to store information.</span></span> <span data-ttu-id="2dd9d-344">SignalR 应用可以将每个连接状态存储在中心的 `Context.Items` 中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-344">SignalR apps can store per connection state in `Context.Items` in the hub.</span></span> <!-- https://github.com/aspnet/SignalR/issues/2139 -->

## <a name="additional-resources"></a><span data-ttu-id="2dd9d-345">其他资源</span><span class="sxs-lookup"><span data-stu-id="2dd9d-345">Additional resources</span></span>

<xref:host-and-deploy/web-farm>
::: moniker-end

::: moniker range="< aspnetcore-3.0"

<span data-ttu-id="2dd9d-346">作者：[Rick Anderson](https://twitter.com/RickAndMSFT)、[Steve Smith](https://ardalis.com/)、[Diana LaRose](https://github.com/DianaLaRose) 和 [Luke Latham](https://github.com/guardrex)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-346">By [Rick Anderson](https://twitter.com/RickAndMSFT), [Steve Smith](https://ardalis.com/), [Diana LaRose](https://github.com/DianaLaRose), and [Luke Latham](https://github.com/guardrex)</span></span>

<span data-ttu-id="2dd9d-347">HTTP 是无状态的协议。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-347">HTTP is a stateless protocol.</span></span> <span data-ttu-id="2dd9d-348">不采取其他步骤的情况下，HTTP 请求是不保留用户值或应用状态的独立消息。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-348">Without taking additional steps, HTTP requests are independent messages that don't retain user values or app state.</span></span> <span data-ttu-id="2dd9d-349">本文介绍了几种保留请求间用户数据和应用状态的方法。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-349">This article describes several approaches to preserve user data and app state between requests.</span></span>

<span data-ttu-id="2dd9d-350">[查看或下载示例代码](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/app-state/samples)（[如何下载](xref:index#how-to-download-a-sample)）</span><span class="sxs-lookup"><span data-stu-id="2dd9d-350">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/app-state/samples) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="state-management"></a><span data-ttu-id="2dd9d-351">状态管理</span><span class="sxs-lookup"><span data-stu-id="2dd9d-351">State management</span></span>

<span data-ttu-id="2dd9d-352">可以使用几种方法存储状态。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-352">State can be stored using several approaches.</span></span> <span data-ttu-id="2dd9d-353">本主题稍后将对每个方法进行介绍。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-353">Each approach is described later in this topic.</span></span>

| <span data-ttu-id="2dd9d-354">存储方法</span><span class="sxs-lookup"><span data-stu-id="2dd9d-354">Storage approach</span></span> | <span data-ttu-id="2dd9d-355">存储机制</span><span class="sxs-lookup"><span data-stu-id="2dd9d-355">Storage mechanism</span></span> |
| ---------------- | ----------------- |
| <span data-ttu-id="2dd9d-356">[Cookie](#cookies)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-356">[Cookies](#cookies)</span></span> | <span data-ttu-id="2dd9d-357">HTTP cookie（可能包括使用服务器端应用代码存储的数据）</span><span class="sxs-lookup"><span data-stu-id="2dd9d-357">HTTP cookies (may include data stored using server-side app code)</span></span> |
| [<span data-ttu-id="2dd9d-358">Session State</span><span class="sxs-lookup"><span data-stu-id="2dd9d-358">Session state</span></span>](#session-state) | <span data-ttu-id="2dd9d-359">HTTP cookie 和服务器端应用代码</span><span class="sxs-lookup"><span data-stu-id="2dd9d-359">HTTP cookies and server-side app code</span></span> |
| [<span data-ttu-id="2dd9d-360">TempData</span><span class="sxs-lookup"><span data-stu-id="2dd9d-360">TempData</span></span>](#tempdata) | <span data-ttu-id="2dd9d-361">HTTP cookie 或会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-361">HTTP cookies or session state</span></span> |
| [<span data-ttu-id="2dd9d-362">Query Strings</span><span class="sxs-lookup"><span data-stu-id="2dd9d-362">Query strings</span></span>](#query-strings) | <span data-ttu-id="2dd9d-363">HTTP 查询字符串</span><span class="sxs-lookup"><span data-stu-id="2dd9d-363">HTTP query strings</span></span> |
| [<span data-ttu-id="2dd9d-364">Hidden Fields</span><span class="sxs-lookup"><span data-stu-id="2dd9d-364">Hidden fields</span></span>](#hidden-fields) | <span data-ttu-id="2dd9d-365">HTTP 窗体字段</span><span class="sxs-lookup"><span data-stu-id="2dd9d-365">HTTP form fields</span></span> |
| [<span data-ttu-id="2dd9d-366">HttpContext.Items</span><span class="sxs-lookup"><span data-stu-id="2dd9d-366">HttpContext.Items</span></span>](#httpcontextitems) | <span data-ttu-id="2dd9d-367">服务器端应用代码</span><span class="sxs-lookup"><span data-stu-id="2dd9d-367">Server-side app code</span></span> |
| [<span data-ttu-id="2dd9d-368">Cache</span><span class="sxs-lookup"><span data-stu-id="2dd9d-368">Cache</span></span>](#cache) | <span data-ttu-id="2dd9d-369">服务器端应用代码</span><span class="sxs-lookup"><span data-stu-id="2dd9d-369">Server-side app code</span></span> |
| [<span data-ttu-id="2dd9d-370">Dependency Injection</span><span class="sxs-lookup"><span data-stu-id="2dd9d-370">Dependency Injection</span></span>](#dependency-injection) | <span data-ttu-id="2dd9d-371">服务器端应用代码</span><span class="sxs-lookup"><span data-stu-id="2dd9d-371">Server-side app code</span></span> |

## <a name="cookies"></a><span data-ttu-id="2dd9d-372">Cookies</span><span class="sxs-lookup"><span data-stu-id="2dd9d-372">Cookies</span></span>

<span data-ttu-id="2dd9d-373">Cookie 存储请求之间的数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-373">Cookies store data across requests.</span></span> <span data-ttu-id="2dd9d-374">因为 cookie 是随每个请求发送的，所以它们的大小应该保持在最低限度。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-374">Because cookies are sent with every request, their size should be kept to a minimum.</span></span> <span data-ttu-id="2dd9d-375">理想情况下，仅标识符应存储在 cookie 中，而数据则由应用存储。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-375">Ideally, only an identifier should be stored in a cookie with the data stored by the app.</span></span> <span data-ttu-id="2dd9d-376">大多数浏览器 cookie 大小限制为 4096 个字节。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-376">Most browsers restrict cookie size to 4096 bytes.</span></span> <span data-ttu-id="2dd9d-377">每个域仅有有限数量的 cookie 可用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-377">Only a limited number of cookies are available for each domain.</span></span>

<span data-ttu-id="2dd9d-378">由于 cookie 易被篡改，因此它们必须由服务器进行验证。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-378">Because cookies are subject to tampering, they must be validated by the app.</span></span> <span data-ttu-id="2dd9d-379">客户端上的 Cookie 可能被用户删除或者过期。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-379">Cookies can be deleted by users and expire on clients.</span></span> <span data-ttu-id="2dd9d-380">但是，cookie 通常是客户端上最持久的数据暂留形式。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-380">However, cookies are generally the most durable form of data persistence on the client.</span></span>

<span data-ttu-id="2dd9d-381">Cookie 通常用于个性化设置，其中的内容是为已知用户定制的。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-381">Cookies are often used for personalization, where content is customized for a known user.</span></span> <span data-ttu-id="2dd9d-382">大多数情况下，仅标识用户，但不对其进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-382">The user is only identified and not authenticated in most cases.</span></span> <span data-ttu-id="2dd9d-383">cookie 可以存储用户名、帐户名或唯一的用户 ID（例如 GUID）。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-383">The cookie can store the user's name, account name, or unique user ID (such as a GUID).</span></span> <span data-ttu-id="2dd9d-384">然后，可以使用 cookie 访问用户的个性化设置，例如首选的网站背景色。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-384">You can then use the cookie to access the user's personalized settings, such as their preferred website background color.</span></span>

<span data-ttu-id="2dd9d-385">发布 cookie 和处理隐私问题时，请留意[欧盟一般数据保护条例 (GDPR)](https://ec.europa.eu/info/law/law-topic/data-protection)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-385">Be mindful of the [European Union General Data Protection Regulations (GDPR)](https://ec.europa.eu/info/law/law-topic/data-protection) when issuing cookies and dealing with privacy concerns.</span></span> <span data-ttu-id="2dd9d-386">有关详细信息，请参阅 [ASP.NET Core 中的一般数据保护条例 (GDPR) 支持](xref:security/gdpr)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-386">For more information, see [General Data Protection Regulation (GDPR) support in ASP.NET Core](xref:security/gdpr).</span></span>

## <a name="session-state"></a><span data-ttu-id="2dd9d-387">会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-387">Session state</span></span>

<span data-ttu-id="2dd9d-388">会话状态是在用户浏览 Web 应用时用来存储用户数据的 ASP.NET Core 方案。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-388">Session state is an ASP.NET Core scenario for storage of user data while the user browses a web app.</span></span> <span data-ttu-id="2dd9d-389">会话状态使用应用维护的存储来保存客户端所有请求的数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-389">Session state uses a store maintained by the app to persist data across requests from a client.</span></span> <span data-ttu-id="2dd9d-390">会话数据由缓存支持并被视为临时数据 - 站点应在没有会话数据的情况下继续运行。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-390">The session data is backed by a cache and considered ephemeral data&mdash;the site should continue to function without the session data.</span></span> <span data-ttu-id="2dd9d-391">关键应用程序数据应存储在用户数据库中，并仅作为性能优化缓存在会话中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-391">Critical application data should be stored in the user database and cached in session only as a performance optimization.</span></span>

> [!NOTE]
> <span data-ttu-id="2dd9d-392">[SignalR](xref:signalr/index) 应用不支持会话，因为 [SignalR 中心](xref:signalr/hubs)可能独立于 HTTP 上下文执行。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-392">Session isn't supported in [SignalR](xref:signalr/index) apps because a [SignalR Hub](xref:signalr/hubs) may execute independent of an HTTP context.</span></span> <span data-ttu-id="2dd9d-393">例如，当中心打开的长轮询请求超出请求的 HTTP 上下文的生存期时，可能发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-393">For example, this can occur when a long polling request is held open by a hub beyond the lifetime of the request's HTTP context.</span></span>

<span data-ttu-id="2dd9d-394">ASP.NET Core 通过向客户端提供包含会话 ID 的 cookie 来维护会话状态，该会话 ID 与每个请求一起发送到应用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-394">ASP.NET Core maintains session state by providing a cookie to the client that contains a session ID, which is sent to the app with each request.</span></span> <span data-ttu-id="2dd9d-395">应用使用会话 ID 来获取会话数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-395">The app uses the session ID to fetch the session data.</span></span>

<span data-ttu-id="2dd9d-396">会话状态具有以下行为：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-396">Session state exhibits the following behaviors:</span></span>

* <span data-ttu-id="2dd9d-397">由于会话 cookie 是特定于浏览器的，因此不能跨浏览器共享会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-397">Because the session cookie is specific to the browser, sessions aren't shared across browsers.</span></span>
* <span data-ttu-id="2dd9d-398">浏览器会话结束时删除会话 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-398">Session cookies are deleted when the browser session ends.</span></span>
* <span data-ttu-id="2dd9d-399">如果收到过期的会话 cookie，则创建使用相同会话 cookie 的新会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-399">If a cookie is received for an expired session, a new session is created that uses the same session cookie.</span></span>
* <span data-ttu-id="2dd9d-400">不会保留空会话 - 会话中必须设置了至少一个值以保存所有请求的会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-400">Empty sessions aren't retained&mdash;the session must have at least one value set into it to persist the session across requests.</span></span> <span data-ttu-id="2dd9d-401">会话未保留时，为每个新的请求生成新会话 ID。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-401">When a session isn't retained, a new session ID is generated for each new request.</span></span>
* <span data-ttu-id="2dd9d-402">应用在上次请求后保留会话的时间有限。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-402">The app retains a session for a limited time after the last request.</span></span> <span data-ttu-id="2dd9d-403">应用设置会话超时，或者使用 20 分钟的默认值。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-403">The app either sets the session timeout or uses the default value of 20 minutes.</span></span> <span data-ttu-id="2dd9d-404">会话状态适用于存储特定于特定会话的用户数据，但该数据无需永久的会话存储。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-404">Session state is ideal for storing user data that's specific to a particular session but where the data doesn't require permanent storage across sessions.</span></span>
* <span data-ttu-id="2dd9d-405">会话数据在调用 <xref:Microsoft.AspNetCore.Http.ISession.Clear%2A?displayProperty=nameWithType> 实现或会话到期时删除。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-405">Session data is deleted either when the <xref:Microsoft.AspNetCore.Http.ISession.Clear%2A?displayProperty=nameWithType> implementation is called or when the session expires.</span></span>
* <span data-ttu-id="2dd9d-406">没有默认机制告知客户端浏览器已关闭或者客户端上的会话 cookie 被删除或过期的应用代码。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-406">There's no default mechanism to inform app code that a client browser has been closed or when the session cookie is deleted or expired on the client.</span></span>
* <span data-ttu-id="2dd9d-407">ASP.NET Core MVC 和 Razor Pages 模板包括对一般数据保护条例 (GDPR) 的支持。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-407">The ASP.NET Core MVC and Razor pages templates include support for General Data Protection Regulation (GDPR).</span></span> <span data-ttu-id="2dd9d-408">默认情况下，会话状态 cookie 不标记为“基本”，因此，除非站点访问者允许跟踪，否则会话状态不起作用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-408">Session state cookies aren't marked essential by default, so session state isn't functional unless tracking is permitted by the site visitor.</span></span> <span data-ttu-id="2dd9d-409">有关详细信息，请参阅 <xref:security/gdpr#tempdata-provider-and-session-state-cookies-arent-essential>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-409">For more information, see <xref:security/gdpr#tempdata-provider-and-session-state-cookies-arent-essential>.</span></span>

> [!WARNING]
> <span data-ttu-id="2dd9d-410">请勿将敏感数据存储在会话状态中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-410">Don't store sensitive data in session state.</span></span> <span data-ttu-id="2dd9d-411">用户可能不会关闭浏览器或清除会话 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-411">The user might not close the browser and clear the session cookie.</span></span> <span data-ttu-id="2dd9d-412">某些浏览器会保留浏览器窗口之间的有效会话 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-412">Some browsers maintain valid session cookies across browser windows.</span></span> <span data-ttu-id="2dd9d-413">会话可能不限于单个用户 &mdash; 下一个用户可能继续使用同一会话 cookie 浏览应用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-413">A session might not be restricted to a single user&mdash;the next user might continue to browse the app with the same session cookie.</span></span>

<span data-ttu-id="2dd9d-414">内存中缓存提供程序在应用驻留的服务器内存中存储会话数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-414">The in-memory cache provider stores session data in the memory of the server where the app resides.</span></span> <span data-ttu-id="2dd9d-415">在服务器场方案中：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-415">In a server farm scenario:</span></span>

* <span data-ttu-id="2dd9d-416">使用粘性会话将每个会话加入到单独服务器上的特定应用实例。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-416">Use *sticky sessions* to tie each session to a specific app instance on an individual server.</span></span> <span data-ttu-id="2dd9d-417">默认情况下，[Azure 应用服务](https://azure.microsoft.com/services/app-service/)使用[应用程序请求路由 (ARR)](/iis/extensions/planning-for-arr/using-the-application-request-routing-module) 强制实施粘性会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-417">[Azure App Service](https://azure.microsoft.com/services/app-service/) uses [Application Request Routing (ARR)](/iis/extensions/planning-for-arr/using-the-application-request-routing-module) to enforce sticky sessions by default.</span></span> <span data-ttu-id="2dd9d-418">然而，粘性会话可能会影响可伸缩性，并使 Web 应用更新变得复杂。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-418">However, sticky sessions can affect scalability and complicate web app updates.</span></span> <span data-ttu-id="2dd9d-419">更好的方法是使用 Redis 或 SQL Server 分布式缓存，它们不需要粘性会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-419">A better approach is to use a Redis or SQL Server distributed cache, which doesn't require sticky sessions.</span></span> <span data-ttu-id="2dd9d-420">有关详细信息，请参阅 <xref:performance/caching/distributed>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-420">For more information, see <xref:performance/caching/distributed>.</span></span>
* <span data-ttu-id="2dd9d-421">会话 cookie 通过 <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> 进行加密。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-421">The session cookie is encrypted via <xref:Microsoft.AspNetCore.DataProtection.IDataProtector>.</span></span> <span data-ttu-id="2dd9d-422">必须正确配置数据保护，以在每台计算机上读取会话 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-422">Data Protection must be properly configured to read session cookies on each machine.</span></span> <span data-ttu-id="2dd9d-423">有关详细信息，请参阅 <xref:security/data-protection/introduction> 和[密钥存储提供程序](xref:security/data-protection/implementation/key-storage-providers)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-423">For more information, see <xref:security/data-protection/introduction> and [Key storage providers](xref:security/data-protection/implementation/key-storage-providers).</span></span>

### <a name="configure-session-state"></a><span data-ttu-id="2dd9d-424">配置会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-424">Configure session state</span></span>

<span data-ttu-id="2dd9d-425">[Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app) 中包含的 [Microsoft.AspNetCore.Session](https://www.nuget.org/packages/Microsoft.AspNetCore.Session/) 包提供中间件来管理会话状态。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-425">The [Microsoft.AspNetCore.Session](https://www.nuget.org/packages/Microsoft.AspNetCore.Session/) package, which is included in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app), provides middleware for managing session state.</span></span> <span data-ttu-id="2dd9d-426">若要启用会话中间件，`Startup` 必须包含：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-426">To enable the session middleware, `Startup` must contain:</span></span>

* <span data-ttu-id="2dd9d-427">任何 <xref:Microsoft.Extensions.Caching.Distributed.IDistributedCache> 内存缓存。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-427">Any of the <xref:Microsoft.Extensions.Caching.Distributed.IDistributedCache> memory caches.</span></span> <span data-ttu-id="2dd9d-428">`IDistributedCache` 实现用作会话后备存储。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-428">The `IDistributedCache` implementation is used as a backing store for session.</span></span> <span data-ttu-id="2dd9d-429">有关详细信息，请参阅 <xref:performance/caching/distributed>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-429">For more information, see <xref:performance/caching/distributed>.</span></span>
* <span data-ttu-id="2dd9d-430">对 `ConfigureServices` 中 <xref:Microsoft.Extensions.DependencyInjection.SessionServiceCollectionExtensions.AddSession%2A> 的调用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-430">A call to <xref:Microsoft.Extensions.DependencyInjection.SessionServiceCollectionExtensions.AddSession%2A> in `ConfigureServices`.</span></span>
* <span data-ttu-id="2dd9d-431">对 `Configure` 中 <xref:Microsoft.AspNetCore.Builder.SessionMiddlewareExtensions.UseSession%2A> 的调用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-431">A call to <xref:Microsoft.AspNetCore.Builder.SessionMiddlewareExtensions.UseSession%2A> in `Configure`.</span></span>

<span data-ttu-id="2dd9d-432">以下代码演示如何使用 `IDistributedCache` 的默认内存中实现设置内存中会话提供程序：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-432">The following code shows how to set up the in-memory session provider with a default in-memory implementation of `IDistributedCache`:</span></span>

[!code-csharp[](app-state/samples/2.x/SessionSample/Startup.cs?name=snippet1&highlight=5-14,34)]

<span data-ttu-id="2dd9d-433">中间件的顺序很重要。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-433">The order of middleware is important.</span></span> <span data-ttu-id="2dd9d-434">在前面的示例中，在 `UseMvc` 之后调用 `UseSession` 时会发生 `InvalidOperationException` 异常。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-434">In the preceding example, an `InvalidOperationException` exception occurs when `UseSession` is invoked after `UseMvc`.</span></span> <span data-ttu-id="2dd9d-435">有关详细信息，请参阅[中间件排序](xref:fundamentals/middleware/index#order)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-435">For more information, see [Middleware Ordering](xref:fundamentals/middleware/index#order).</span></span>

<span data-ttu-id="2dd9d-436"><xref:Microsoft.AspNetCore.Http.HttpContext.Session?displayProperty=nameWithType> 在会话状态配置后可用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-436"><xref:Microsoft.AspNetCore.Http.HttpContext.Session?displayProperty=nameWithType> is available after session state is configured.</span></span>

<span data-ttu-id="2dd9d-437">调用 `UseSession` 以前无法访问 `HttpContext.Session`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-437">`HttpContext.Session` can't be accessed before `UseSession` has been called.</span></span>

<span data-ttu-id="2dd9d-438">在应用已经开始写入到响应流之后，不能创建有新会话 cookie 的新会话。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-438">A new session with a new session cookie can't be created after the app has begun writing to the response stream.</span></span> <span data-ttu-id="2dd9d-439">此异常记录在 Web 服务器日志中但不显示在浏览器中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-439">The exception is recorded in the web server log and not displayed in the browser.</span></span>

### <a name="load-session-state-asynchronously"></a><span data-ttu-id="2dd9d-440">以异步方式加载会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-440">Load session state asynchronously</span></span>

<span data-ttu-id="2dd9d-441">只有当 <xref:Microsoft.AspNetCore.Http.ISession.LoadAsync%2A?displayProperty=nameWithType> 方法是先于 <xref:Microsoft.AspNetCore.Http.ISession.TryGetValue%2A>、<xref:Microsoft.AspNetCore.Http.ISession.Set%2A> 或 <xref:Microsoft.AspNetCore.Http.ISession.Remove%2A> 方法显式调用时，ASP.NET Core 中的默认会话提供程序才会从基础 <xref:Microsoft.Extensions.Caching.Distributed.IDistributedCache> 后备存储中异步加载会话记录。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-441">The default session provider in ASP.NET Core loads session records from the underlying <xref:Microsoft.Extensions.Caching.Distributed.IDistributedCache> backing store asynchronously only if the <xref:Microsoft.AspNetCore.Http.ISession.LoadAsync%2A?displayProperty=nameWithType> method is explicitly called before the <xref:Microsoft.AspNetCore.Http.ISession.TryGetValue%2A>, <xref:Microsoft.AspNetCore.Http.ISession.Set%2A>, or <xref:Microsoft.AspNetCore.Http.ISession.Remove%2A> methods.</span></span> <span data-ttu-id="2dd9d-442">如果未先调用 `LoadAsync`，则会同步加载基础会话记录，这可能对性能产生大规模影响。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-442">If `LoadAsync` isn't called first, the underlying session record is loaded synchronously, which can incur a performance penalty at scale.</span></span>

<span data-ttu-id="2dd9d-443">若要让应用强制执行此模式，请使用在 `LoadAsync` 方法没有先于 `TryGetValue`、`Set` 或 `Remove` 调用时抛出异常的版本来包装 <xref:Microsoft.AspNetCore.Session.DistributedSessionStore> 和 <xref:Microsoft.AspNetCore.Session.DistributedSession> 实现。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-443">To have apps enforce this pattern, wrap the <xref:Microsoft.AspNetCore.Session.DistributedSessionStore> and <xref:Microsoft.AspNetCore.Session.DistributedSession> implementations with versions that throw an exception if the `LoadAsync` method isn't called before `TryGetValue`, `Set`, or `Remove`.</span></span> <span data-ttu-id="2dd9d-444">在服务容器中注册的已包装的版本。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-444">Register the wrapped versions in the services container.</span></span>

### <a name="session-options"></a><span data-ttu-id="2dd9d-445">会话选项</span><span class="sxs-lookup"><span data-stu-id="2dd9d-445">Session options</span></span>

<span data-ttu-id="2dd9d-446">若要重写会话默认值，请使用 <xref:Microsoft.AspNetCore.Builder.SessionOptions>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-446">To override session defaults, use <xref:Microsoft.AspNetCore.Builder.SessionOptions>.</span></span>

| <span data-ttu-id="2dd9d-447">选项</span><span class="sxs-lookup"><span data-stu-id="2dd9d-447">Option</span></span> | <span data-ttu-id="2dd9d-448">描述</span><span class="sxs-lookup"><span data-stu-id="2dd9d-448">Description</span></span> |
| ------ | ----------- |
| <xref:Microsoft.AspNetCore.Builder.SessionOptions.Cookie> | <span data-ttu-id="2dd9d-449">确定用于创建 cookie 的设置。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-449">Determines the settings used to create the cookie.</span></span> <span data-ttu-id="2dd9d-450"><xref:Microsoft.AspNetCore.Http.CookieBuilder.Name> 默认为 <xref:Microsoft.AspNetCore.Session.SessionDefaults.CookieName?displayProperty=nameWithType> (`.AspNetCore.Session`)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-450"><xref:Microsoft.AspNetCore.Http.CookieBuilder.Name> defaults to <xref:Microsoft.AspNetCore.Session.SessionDefaults.CookieName?displayProperty=nameWithType> (`.AspNetCore.Session`).</span></span> <span data-ttu-id="2dd9d-451"><xref:Microsoft.AspNetCore.Http.CookieBuilder.Path> 默认为 <xref:Microsoft.AspNetCore.Session.SessionDefaults.CookiePath?displayProperty=nameWithType> (`/`)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-451"><xref:Microsoft.AspNetCore.Http.CookieBuilder.Path> defaults to <xref:Microsoft.AspNetCore.Session.SessionDefaults.CookiePath?displayProperty=nameWithType> (`/`).</span></span> <span data-ttu-id="2dd9d-452"><xref:Microsoft.AspNetCore.Http.CookieBuilder.SameSite> 默认为 <xref:Microsoft.AspNetCore.Http.SameSiteMode.Lax?displayProperty=nameWithType> (`1`)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-452"><xref:Microsoft.AspNetCore.Http.CookieBuilder.SameSite> defaults to <xref:Microsoft.AspNetCore.Http.SameSiteMode.Lax?displayProperty=nameWithType> (`1`).</span></span> <span data-ttu-id="2dd9d-453"><xref:Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly> 默认为 `true`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-453"><xref:Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly> defaults to `true`.</span></span> <span data-ttu-id="2dd9d-454"><xref:Microsoft.AspNetCore.Http.CookieBuilder.IsEssential> 默认为 `false`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-454"><xref:Microsoft.AspNetCore.Http.CookieBuilder.IsEssential> defaults to `false`.</span></span> |
| <xref:Microsoft.AspNetCore.Builder.SessionOptions.IdleTimeout> | <span data-ttu-id="2dd9d-455">`IdleTimeout` 显示放弃其内容前，内容可以空闲多长时间。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-455">The `IdleTimeout` indicates how long the session can be idle before its contents are abandoned.</span></span> <span data-ttu-id="2dd9d-456">每个会话访问都会重置超时。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-456">Each session access resets the timeout.</span></span> <span data-ttu-id="2dd9d-457">此设置仅适用于会话内容，不适用于 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-457">This setting only applies to the content of the session, not the cookie.</span></span> <span data-ttu-id="2dd9d-458">默认为 20 分钟。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-458">The default is 20 minutes.</span></span> |
| <xref:Microsoft.AspNetCore.Builder.SessionOptions.IOTimeout> | <span data-ttu-id="2dd9d-459">允许从存储加载会话或者将其提交回存储的最大时长。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-459">The maximum amount of time allowed to load a session from the store or to commit it back to the store.</span></span> <span data-ttu-id="2dd9d-460">此设置可能仅适用于异步操作。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-460">This setting may only apply to asynchronous operations.</span></span> <span data-ttu-id="2dd9d-461">可以使用 <xref:System.Threading.Timeout.InfiniteTimeSpan> 来禁用此超时。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-461">This timeout can be disabled using <xref:System.Threading.Timeout.InfiniteTimeSpan>.</span></span> <span data-ttu-id="2dd9d-462">默认值为 1 分钟。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-462">The default is 1 minute.</span></span> |

<span data-ttu-id="2dd9d-463">会话使用 cookie 跟踪和标识来自单个浏览器的请求。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-463">Session uses a cookie to track and identify requests from a single browser.</span></span> <span data-ttu-id="2dd9d-464">默认情况下，此 cookie 名为 `.AspNetCore.Session`，并使用路径 `/`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-464">By default, this cookie is named `.AspNetCore.Session`, and it uses a path of `/`.</span></span> <span data-ttu-id="2dd9d-465">由于 cookie 默认值没有指定域，因此页面上的客户端脚本无法使用它（因为 <xref:Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly> 默认为 `true`）。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-465">Because the cookie default doesn't specify a domain, it isn't made available to the client-side script on the page (because <xref:Microsoft.AspNetCore.Http.CookieBuilder.HttpOnly> defaults to `true`).</span></span>

<span data-ttu-id="2dd9d-466">若要重写 cookie 会话默认值，请使用 `SessionOptions`：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-466">To override cookie session defaults, use `SessionOptions`:</span></span>

[!code-csharp[](app-state/samples_snapshot/2.x/SessionSample/Startup.cs?name=snippet1&highlight=14-19)]

<span data-ttu-id="2dd9d-467">应用使用 <xref:Microsoft.AspNetCore.Builder.SessionOptions.IdleTimeout> 属性来确定在会话空闲多长时间后它在服务器缓存中的内容就会被放弃。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-467">The app uses the <xref:Microsoft.AspNetCore.Builder.SessionOptions.IdleTimeout> property to determine how long a session can be idle before its contents in the server's cache are abandoned.</span></span> <span data-ttu-id="2dd9d-468">此属性独立于 cookie 到期时间。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-468">This property is independent of the cookie expiration.</span></span> <span data-ttu-id="2dd9d-469">通过[会话中间件](xref:Microsoft.AspNetCore.Session.SessionMiddleware)传递的每个请求都会重置超时。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-469">Each request that passes through the [Session Middleware](xref:Microsoft.AspNetCore.Session.SessionMiddleware) resets the timeout.</span></span>

<span data-ttu-id="2dd9d-470">会话状态为“非锁定”。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-470">Session state is *non-locking*.</span></span> <span data-ttu-id="2dd9d-471">如果两个请求同时尝试修改同一会话的内容，则后一个请求替代前一个请求。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-471">If two requests simultaneously attempt to modify the contents of a session, the last request overrides the first.</span></span> <span data-ttu-id="2dd9d-472">`Session` 是作为一个连贯会话实现的，这意味着所有内容都存储在一起。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-472">`Session` is implemented as a *coherent session*, which means that all the contents are stored together.</span></span> <span data-ttu-id="2dd9d-473">两个请求试图修改不同的会话值时，后一个请求可能替代前一个做出的会话更改。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-473">When two requests seek to modify different session values, the last request may override session changes made by the first.</span></span>

### <a name="set-and-get-session-values"></a><span data-ttu-id="2dd9d-474">设置和获取会话值</span><span class="sxs-lookup"><span data-stu-id="2dd9d-474">Set and get Session values</span></span>

<span data-ttu-id="2dd9d-475">会话状态是通过 Razor Pages <xref:Microsoft.AspNetCore.Mvc.RazorPages.PageModel> 类或包含 <xref:Microsoft.AspNetCore.Http.HttpContext.Session?displayProperty=nameWithType> 的 MVC <xref:Microsoft.AspNetCore.Mvc.Controller> 类进行访问。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-475">Session state is accessed from a Razor Pages <xref:Microsoft.AspNetCore.Mvc.RazorPages.PageModel> class or MVC <xref:Microsoft.AspNetCore.Mvc.Controller> class with <xref:Microsoft.AspNetCore.Http.HttpContext.Session?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2dd9d-476">此属性是 <xref:Microsoft.AspNetCore.Http.ISession> 实现。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-476">This property is an <xref:Microsoft.AspNetCore.Http.ISession> implementation.</span></span>

<span data-ttu-id="2dd9d-477">`ISession` 实现提供用于设置和检索整数和字符串值的若干扩展方法。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-477">The `ISession` implementation provides several extension methods to set and retrieve integer and string values.</span></span> <span data-ttu-id="2dd9d-478">当项目引用 [Microsoft.AspNetCore.Http.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.Http.Extensions/) 包时，扩展方法位于 <xref:Microsoft.AspNetCore.Http> 命名空间中（添加 `using Microsoft.AspNetCore.Http;` 语句可以获取对扩展方法的访问权限）。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-478">The extension methods are in the <xref:Microsoft.AspNetCore.Http> namespace (add a `using Microsoft.AspNetCore.Http;` statement to gain access to the extension methods) when the [Microsoft.AspNetCore.Http.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.Http.Extensions/) package is referenced by the project.</span></span> <span data-ttu-id="2dd9d-479">这两个包均包括在 [Microsoft.AspNetCore.App 元包](xref:fundamentals/metapackage-app)中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-479">Both packages are included in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="2dd9d-480">`ISession` 扩展方法：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-480">`ISession` extension methods:</span></span>

* [<span data-ttu-id="2dd9d-481">Get(ISession, String)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-481">Get(ISession, String)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.Get%2A)
* [<span data-ttu-id="2dd9d-482">GetInt32(ISession, String)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-482">GetInt32(ISession, String)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.GetInt32%2A)
* [<span data-ttu-id="2dd9d-483">GetString(ISession, String)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-483">GetString(ISession, String)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.GetString%2A)
* [<span data-ttu-id="2dd9d-484">SetInt32(ISession, String, Int32)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-484">SetInt32(ISession, String, Int32)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.SetInt32%2A)
* [<span data-ttu-id="2dd9d-485">SetString(ISession, String, String)</span><span class="sxs-lookup"><span data-stu-id="2dd9d-485">SetString(ISession, String, String)</span></span>](xref:Microsoft.AspNetCore.Http.SessionExtensions.SetString%2A)

<span data-ttu-id="2dd9d-486">以下示例在 Razor Pages 页中检索 `IndexModel.SessionKeyName` 键（示例应用中的 `_Name`）的会话值：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-486">The following example retrieves the session value for the `IndexModel.SessionKeyName` key (`_Name` in the sample app) in a Razor Pages page:</span></span>

```csharp
@page
@using Microsoft.AspNetCore.Http
@model IndexModel

...

Name: @HttpContext.Session.GetString(IndexModel.SessionKeyName)
```

<span data-ttu-id="2dd9d-487">以下示例显示如何设置和获取整数和字符串：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-487">The following example shows how to set and get an integer and a string:</span></span>

[!code-csharp[](app-state/samples/2.x/SessionSample/Pages/Index.cshtml.cs?name=snippet1&highlight=18-19,22-23)]

<span data-ttu-id="2dd9d-488">必须对所有会话数据进行序列化以启用分布式缓存方案，即使是在使用内存中缓存的时候。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-488">All session data must be serialized to enable a distributed cache scenario, even when using the in-memory cache.</span></span> <span data-ttu-id="2dd9d-489">字符串和整数序列化程序是由 <xref:Microsoft.AspNetCore.Http.ISession> 的扩展方法提供。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-489">String and integer serializers are provided by the extension methods of <xref:Microsoft.AspNetCore.Http.ISession>).</span></span> <span data-ttu-id="2dd9d-490">用户必须使用另一种机制（例如 JSON）序列化复杂类型。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-490">Complex types must be serialized by the user using another mechanism, such as JSON.</span></span>

<span data-ttu-id="2dd9d-491">添加以下扩展方法以设置和获取可序列化的对象：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-491">Add the following extension methods to set and get serializable objects:</span></span>

[!code-csharp[](app-state/samples/2.x/SessionSample/Extensions/SessionExtensions.cs?name=snippet1)]

<span data-ttu-id="2dd9d-492">以下示例演示如何使用扩展方法设置和获取可序列化的对象：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-492">The following example shows how to set and get a serializable object with the extension methods:</span></span>

[!code-csharp[](app-state/samples/2.x/SessionSample/Pages/Index.cshtml.cs?name=snippet2)]

## <a name="tempdata"></a><span data-ttu-id="2dd9d-493">TempData</span><span class="sxs-lookup"><span data-stu-id="2dd9d-493">TempData</span></span>

<span data-ttu-id="2dd9d-494">ASP.NET Core 公开 Razor Pages [TempData](xref:Microsoft.AspNetCore.Mvc.RazorPages.PageModel.TempData) 或控制器 <xref:Microsoft.AspNetCore.Mvc.Controller.TempData>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-494">ASP.NET Core exposes the Razor Pages [TempData](xref:Microsoft.AspNetCore.Mvc.RazorPages.PageModel.TempData) or Controller <xref:Microsoft.AspNetCore.Mvc.Controller.TempData>.</span></span> <span data-ttu-id="2dd9d-495">在另一个请求读取数据之前，此属性将读取此数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-495">This property stores data until it's read in another request.</span></span> <span data-ttu-id="2dd9d-496">[Keep(String)](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Keep*) 和 [Peek(string)](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Peek*) 方法可用于检查数据，而无需在请求结束时删除。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-496">[Keep(String)](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Keep*) and [Peek(string)](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Peek*) methods can be used to examine the data without deletion at the end of the request.</span></span> <span data-ttu-id="2dd9d-497">[Keep()](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Keep*) 将标记字典中的所有项以进行保留。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-497">[Keep()](xref:Microsoft.AspNetCore.Mvc.ViewFeatures.ITempDataDictionary.Keep*) marks all items in the dictionary for retention.</span></span> <span data-ttu-id="2dd9d-498">当多个请求需要数据时，`TempData` 非常有助于进行重定向。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-498">`TempData` is particularly useful for redirection when data is required for more than a single request.</span></span> <span data-ttu-id="2dd9d-499">使用 cookie 或会话状态通过 `TempData` 提供程序实现 `TempData`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-499">`TempData` is implemented by `TempData` providers using either cookies or session state.</span></span>

## <a name="tempdata-samples"></a><span data-ttu-id="2dd9d-500">TempData 示例</span><span class="sxs-lookup"><span data-stu-id="2dd9d-500">TempData samples</span></span>

<span data-ttu-id="2dd9d-501">考虑创建客户的以下页面：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-501">Consider the following page that creates a customer:</span></span>

[!code-csharp[](app-state/3.0samples/RazorPagesContacts/Pages/Customers/Create.cshtml.cs?name=snippet&highlight=15-16,30)]

<span data-ttu-id="2dd9d-502">以下页面显示 `TempData["Message"]`：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-502">The following page displays `TempData["Message"]`:</span></span>

[!code-cshtml[](app-state/3.0samples/RazorPagesContacts/Pages/Customers/IndexPeek.cshtml?range=1-14)]

<span data-ttu-id="2dd9d-503">在前面的标记中，在请求结束时，不会删除 `TempData["Message"]`，因为正在使用 `Peek`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-503">In the preceding markup, at the end of the request, `TempData["Message"]` is **not** deleted because `Peek` is used.</span></span> <span data-ttu-id="2dd9d-504">刷新页面将显示 `TempData["Message"]`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-504">Refreshing the page displays `TempData["Message"]`.</span></span>

<span data-ttu-id="2dd9d-505">以下标记类似于前面的代码，但使用 `Keep` 在请求结束时保留数据：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-505">The following markup is similar to the preceding code, but uses `Keep` to preserve the data at the end of the request:</span></span>

[!code-cshtml[](app-state/3.0samples/RazorPagesContacts/Pages/Customers/IndexKeep.cshtml?range=1-14)]

<span data-ttu-id="2dd9d-506">在 IndexPeek 和 IndexKeep 页面之间导航不会删除 `TempData["Message"]`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-506">Navigating between the *IndexPeek* and *IndexKeep* pages won't delete `TempData["Message"]`.</span></span>

<span data-ttu-id="2dd9d-507">以下代码显示 `TempData["Message"]`，但请求结束时，将删除 `TempData["Message"]`：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-507">The following code displays `TempData["Message"]`, but at the end of the request, `TempData["Message"]` is deleted:</span></span>

[!code-cshtml[](app-state/3.0samples/RazorPagesContacts/Pages/Customers/Index.cshtml?range=1-14)]

### <a name="tempdata-providers"></a><span data-ttu-id="2dd9d-508">TempData 提供程序</span><span class="sxs-lookup"><span data-stu-id="2dd9d-508">TempData providers</span></span>

<span data-ttu-id="2dd9d-509">默认情况下使用基于 cookie 的 TempData 提供程序将 TempData 存储于 cookie。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-509">The cookie-based TempData provider is used by default to store TempData in cookies.</span></span>

<span data-ttu-id="2dd9d-510">cookie 数据是先使用 <xref:Microsoft.AspNetCore.DataProtection.IDataProtector>（用 <xref:Microsoft.AspNetCore.WebUtilities.Base64UrlTextEncoder> 编码）进行加密，再进行区块处理。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-510">The cookie data is encrypted using <xref:Microsoft.AspNetCore.DataProtection.IDataProtector>, encoded with <xref:Microsoft.AspNetCore.WebUtilities.Base64UrlTextEncoder>, then chunked.</span></span> <span data-ttu-id="2dd9d-511">因为 cookie 进行了分块，所以 ASP.NET Core 1.x 中的单个 cookie 大小限制不适用。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-511">Because the cookie is chunked, the single cookie size limit found in ASP.NET Core 1.x doesn't apply.</span></span> <span data-ttu-id="2dd9d-512">未压缩 cookie 数据，因为压缩加密的数据会导致安全问题，如 [CRIME](https://wikipedia.org/wiki/CRIME_(security_exploit)) 和 [BREACH](https://wikipedia.org/wiki/BREACH_(security_exploit)) 攻击。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-512">The cookie data isn't compressed because compressing encrypted data can lead to security problems such as the [CRIME](https://wikipedia.org/wiki/CRIME_(security_exploit)) and [BREACH](https://wikipedia.org/wiki/BREACH_(security_exploit)) attacks.</span></span> <span data-ttu-id="2dd9d-513">若要详细了解基于 cookie 的 TempData 提供程序，请参阅 <xref:Microsoft.AspNetCore.Mvc.ViewFeatures.CookieTempDataProvider>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-513">For more information on the cookie-based TempData provider, see <xref:Microsoft.AspNetCore.Mvc.ViewFeatures.CookieTempDataProvider>.</span></span>

### <a name="choose-a-tempdata-provider"></a><span data-ttu-id="2dd9d-514">选择 TempData 提供程序</span><span class="sxs-lookup"><span data-stu-id="2dd9d-514">Choose a TempData provider</span></span>

<span data-ttu-id="2dd9d-515">选择 TempData 提供程序涉及几个注意事项，例如：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-515">Choosing a TempData provider involves several considerations, such as:</span></span>

1. <span data-ttu-id="2dd9d-516">应用是否已使用会话状态？</span><span class="sxs-lookup"><span data-stu-id="2dd9d-516">Does the app already use session state?</span></span> <span data-ttu-id="2dd9d-517">如果是，使用会话状态 TempData 提供程序对应用没有额外的成本（除了数据的大小）。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-517">If so, using the session state TempData provider has no additional cost to the app (aside from the size of the data).</span></span>
2. <span data-ttu-id="2dd9d-518">应用是否只对相对较小的数据量（最多 500 个字节）使用 TempData？</span><span class="sxs-lookup"><span data-stu-id="2dd9d-518">Does the app use TempData only sparingly for relatively small amounts of data (up to 500 bytes)?</span></span> <span data-ttu-id="2dd9d-519">如果是，cookie TempData 提供程序将为每个携带 TempData 的请求增加较小的成本。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-519">If so, the cookie TempData provider adds a small cost to each request that carries TempData.</span></span> <span data-ttu-id="2dd9d-520">如果不是，会话状态 TempData 提供程序有助于在使用 TempData 前，避免在每个请求中来回切换大量数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-520">If not, the session state TempData provider can be beneficial to avoid round-tripping a large amount of data in each request until the TempData is consumed.</span></span>
3. <span data-ttu-id="2dd9d-521">应用是否在多个服务器上的服务器场中运行？</span><span class="sxs-lookup"><span data-stu-id="2dd9d-521">Does the app run in a server farm on multiple servers?</span></span> <span data-ttu-id="2dd9d-522">如果是，无需其他任何配置，即可在数据保护外使用 cookie TempData 提供程序（请参阅 <xref:security/data-protection/introduction>和[密钥存储提供程序](xref:security/data-protection/implementation/key-storage-providers)）。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-522">If so, there's no additional configuration required to use the cookie TempData provider outside of Data Protection (see <xref:security/data-protection/introduction> and [Key storage providers](xref:security/data-protection/implementation/key-storage-providers)).</span></span>

> [!NOTE]
> <span data-ttu-id="2dd9d-523">大多数 Web 客户端（如 Web 浏览器）针对每个 cookie 的最大大小、cookie 总数（或两者）强制实施限制。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-523">Most web clients (such as web browsers) enforce limits on the maximum size of each cookie, the total number of cookies, or both.</span></span> <span data-ttu-id="2dd9d-524">使用 cookie TempData 提供程序时，请验证应用未超过这些限制。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-524">When using the cookie TempData provider, verify the app won't exceed these limits.</span></span> <span data-ttu-id="2dd9d-525">考虑数据的总大小。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-525">Consider the total size of the data.</span></span> <span data-ttu-id="2dd9d-526">解释加密和分块导致的 cookie 大小增加。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-526">Account for increases in cookie size due to encryption and chunking.</span></span>

### <a name="configure-the-tempdata-provider"></a><span data-ttu-id="2dd9d-527">配置 TempData 提供程序</span><span class="sxs-lookup"><span data-stu-id="2dd9d-527">Configure the TempData provider</span></span>

<span data-ttu-id="2dd9d-528">默认情况下启用基于 cookie 的 TempData 提供程序。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-528">The cookie-based TempData provider is enabled by default.</span></span>

<span data-ttu-id="2dd9d-529">若要启用基于会话的 TempData 提供程序，请使用 <xref:Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcBuilderExtensions.AddSessionStateTempDataProvider%2A> 扩展方法：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-529">To enable the session-based TempData provider, use the <xref:Microsoft.Extensions.DependencyInjection.MvcViewFeaturesMvcBuilderExtensions.AddSessionStateTempDataProvider%2A> extension method:</span></span>

[!code-csharp[](app-state/samples_snapshot_2/2.x/SessionSample/Startup.cs?name=snippet1&highlight=11,13,32)]

<span data-ttu-id="2dd9d-530">中间件的顺序很重要。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-530">The order of middleware is important.</span></span> <span data-ttu-id="2dd9d-531">在前面的示例中，在 `UseMvc` 之后调用 `UseSession` 时会发生 `InvalidOperationException` 异常。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-531">In the preceding example, an `InvalidOperationException` exception occurs when `UseSession` is invoked after `UseMvc`.</span></span> <span data-ttu-id="2dd9d-532">有关详细信息，请参阅[中间件排序](xref:fundamentals/middleware/index#order)。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-532">For more information, see [Middleware Ordering](xref:fundamentals/middleware/index#order).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2dd9d-533">如果面向 .NET Framework 并使用基于会话的 TempData 提供程序，请将 [Microsoft.AspNetCore.Session](https://www.nuget.org/packages/Microsoft.AspNetCore.Session/) 包添加到项目。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-533">If targeting .NET Framework and using the session-based TempData provider, add the [Microsoft.AspNetCore.Session](https://www.nuget.org/packages/Microsoft.AspNetCore.Session/) package to the project.</span></span>

## <a name="query-strings"></a><span data-ttu-id="2dd9d-534">查询字符串</span><span class="sxs-lookup"><span data-stu-id="2dd9d-534">Query strings</span></span>

<span data-ttu-id="2dd9d-535">可以将有限的数据从一个请求传递到另一个请求，方法是将其添加到新请求的查询字符串中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-535">A limited amount of data can be passed from one request to another by adding it to the new request's query string.</span></span> <span data-ttu-id="2dd9d-536">这有利于以一种持久的方式捕获状态，这种方式允许通过电子邮件或社交网络共享嵌入式状态的链接。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-536">This is useful for capturing state in a persistent manner that allows links with embedded state to be shared through email or social networks.</span></span> <span data-ttu-id="2dd9d-537">由于 URL 查询字符串是公共的，因此请勿对敏感数据使用查询字符串。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-537">Because URL query strings are public, never use query strings for sensitive data.</span></span>

<span data-ttu-id="2dd9d-538">除了意外的共享，在查询字符串中包含数据还会为[跨站点请求伪造 (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)) 攻击创造机会，从而欺骗用户在通过身份验证时访问恶意网站。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-538">In addition to unintended sharing, including data in query strings can create opportunities for [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)) attacks, which can trick users into visiting malicious sites while authenticated.</span></span> <span data-ttu-id="2dd9d-539">然后，攻击者可以从应用中窃取用户数据，或者代表用户采取恶意操作。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-539">Attackers can then steal user data from the app or take malicious actions on behalf of the user.</span></span> <span data-ttu-id="2dd9d-540">任何保留的应用或会话状态必须防止 CSRF 攻击。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-540">Any preserved app or session state must protect against CSRF attacks.</span></span> <span data-ttu-id="2dd9d-541">有关详细信息，请参阅 <xref:security/anti-request-forgery>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-541">For more information, see <xref:security/anti-request-forgery>.</span></span>

## <a name="hidden-fields"></a><span data-ttu-id="2dd9d-542">隐藏字段</span><span class="sxs-lookup"><span data-stu-id="2dd9d-542">Hidden fields</span></span>

<span data-ttu-id="2dd9d-543">数据可以保存在隐藏的表单域中，并在下一个请求上回发。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-543">Data can be saved in hidden form fields and posted back on the next request.</span></span> <span data-ttu-id="2dd9d-544">这在多页窗体中很常见。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-544">This is common in multi-page forms.</span></span> <span data-ttu-id="2dd9d-545">由于客户端可能篡改数据，因此应用必须始终重新验证存储在隐藏字段中的数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-545">Because the client can potentially tamper with the data, the app must always revalidate the data stored in hidden fields.</span></span>

## <a name="httpcontextitems"></a><span data-ttu-id="2dd9d-546">HttpContext.Items</span><span class="sxs-lookup"><span data-stu-id="2dd9d-546">HttpContext.Items</span></span>

<span data-ttu-id="2dd9d-547"><xref:Microsoft.AspNetCore.Http.HttpContext.Items?displayProperty=nameWithType> 集合用于在处理单个请求时存储数据。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-547">The <xref:Microsoft.AspNetCore.Http.HttpContext.Items?displayProperty=nameWithType> collection is used to store data while processing a single request.</span></span> <span data-ttu-id="2dd9d-548">处理请求后，放弃集合的内容。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-548">The collection's contents are discarded after a request is processed.</span></span> <span data-ttu-id="2dd9d-549">通常使用 `Items` 集合允许组件或中间件在请求期间在不同时间点操作且没有直接传递参数的方法时进行通信。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-549">The `Items` collection is often used to allow components or middleware to communicate when they operate at different points in time during a request and have no direct way to pass parameters.</span></span>

<span data-ttu-id="2dd9d-550">在下面示例中，[中间件](xref:fundamentals/middleware/index)将 `isVerified` 添加到 `Items` 集合。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-550">In the following example, [middleware](xref:fundamentals/middleware/index) adds `isVerified` to the `Items` collection.</span></span>

```csharp
app.Use(async (context, next) =>
{
    // perform some verification
    context.Items["isVerified"] = true;
    await next.Invoke();
});
```

<span data-ttu-id="2dd9d-551">然后，在管道中，另一个中间件可以访问 `isVerified` 的值：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-551">Later in the pipeline, another middleware can access the value of `isVerified`:</span></span>

```csharp
app.Run(async (context) =>
{
    await context.Response.WriteAsync($"Verified: {context.Items["isVerified"]}");
});
```

<span data-ttu-id="2dd9d-552">对于只供单个应用使用的中间件，`string` 键是可以接受的。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-552">For middleware that's only used by a single app, `string` keys are acceptable.</span></span> <span data-ttu-id="2dd9d-553">应用实例间共享的中间件应使用唯一的对象键以避免键冲突。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-553">Middleware shared between app instances should use unique object keys to avoid key collisions.</span></span> <span data-ttu-id="2dd9d-554">以下示例演示如何使用中间件类中定义的唯一对象键：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-554">The following example shows how to use a unique object key defined in a middleware class:</span></span>

[!code-csharp[](app-state/samples/2.x/SessionSample/Middleware/HttpContextItemsMiddleware.cs?name=snippet1&highlight=4,13)]

<span data-ttu-id="2dd9d-555">其他代码可以使用通过中间件类公开的键访问存储在 `HttpContext.Items` 中的值：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-555">Other code can access the value stored in `HttpContext.Items` using the key exposed by the middleware class:</span></span>

[!code-csharp[](app-state/samples/2.x/SessionSample/Pages/Index.cshtml.cs?name=snippet3)]

<span data-ttu-id="2dd9d-556">此方法还有避免在代码中使用关键字符串的优势。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-556">This approach also has the advantage of eliminating the use of key strings in the code.</span></span>

## <a name="cache"></a><span data-ttu-id="2dd9d-557">缓存</span><span class="sxs-lookup"><span data-stu-id="2dd9d-557">Cache</span></span>

<span data-ttu-id="2dd9d-558">缓存是存储和检索数据的有效方法。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-558">Caching is an efficient way to store and retrieve data.</span></span> <span data-ttu-id="2dd9d-559">应用可以控制缓存项的生存期。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-559">The app can control the lifetime of cached items.</span></span>

<span data-ttu-id="2dd9d-560">缓存数据未与特定请求、用户或会话相关联。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-560">Cached data isn't associated with a specific request, user, or session.</span></span> <span data-ttu-id="2dd9d-561">**请注意不要缓存可能由其他用户请求检索的特定于用户的数据。**</span><span class="sxs-lookup"><span data-stu-id="2dd9d-561">**Be careful not to cache user-specific data that may be retrieved by other users' requests.**</span></span>

<span data-ttu-id="2dd9d-562">有关详细信息，请参阅 <xref:performance/caching/response>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-562">For more information, see <xref:performance/caching/response>.</span></span>

## <a name="dependency-injection"></a><span data-ttu-id="2dd9d-563">依赖关系注入</span><span class="sxs-lookup"><span data-stu-id="2dd9d-563">Dependency Injection</span></span>

<span data-ttu-id="2dd9d-564">使用[依赖关系注入](xref:fundamentals/dependency-injection)可向所有用户提供数据：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-564">Use [Dependency Injection](xref:fundamentals/dependency-injection) to make data available to all users:</span></span>

1. <span data-ttu-id="2dd9d-565">定义一项包含数据的服务。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-565">Define a service containing the data.</span></span> <span data-ttu-id="2dd9d-566">例如，定义一个名为 `MyAppData` 的类：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-566">For example, a class named `MyAppData` is defined:</span></span>

    ```csharp
    public class MyAppData
    {
        // Declare properties and methods
    }
    ```

2. <span data-ttu-id="2dd9d-567">将服务类添加到 `Startup.ConfigureServices`：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-567">Add the service class to `Startup.ConfigureServices`:</span></span>

    ```csharp
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddSingleton<MyAppData>();
    }
    ```

3. <span data-ttu-id="2dd9d-568">使用数据服务类：</span><span class="sxs-lookup"><span data-stu-id="2dd9d-568">Consume the data service class:</span></span>

    ```csharp
    public class IndexModel : PageModel
    {
        public IndexModel(MyAppData myService)
        {
            // Do something with the service
            //    Examples: Read data, store in a field or property
        }
    }
    ```

## <a name="common-errors"></a><span data-ttu-id="2dd9d-569">常见错误</span><span class="sxs-lookup"><span data-stu-id="2dd9d-569">Common errors</span></span>

* <span data-ttu-id="2dd9d-570">“在尝试激活‘Microsoft.AspNetCore.Session.DistributedSessionStore’时无法为类型‘Microsoft.Extensions.Caching.Distributed.IDistributedCache’解析服务。”</span><span class="sxs-lookup"><span data-stu-id="2dd9d-570">"Unable to resolve service for type 'Microsoft.Extensions.Caching.Distributed.IDistributedCache' while attempting to activate 'Microsoft.AspNetCore.Session.DistributedSessionStore'."</span></span>

  <span data-ttu-id="2dd9d-571">这通常是由于不能配置至少一个 `IDistributedCache` 实现而造成的。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-571">This is usually caused by failing to configure at least one `IDistributedCache` implementation.</span></span> <span data-ttu-id="2dd9d-572">有关详细信息，请参阅 <xref:performance/caching/distributed> 和 <xref:performance/caching/memory>。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-572">For more information, see <xref:performance/caching/distributed> and <xref:performance/caching/memory>.</span></span>

* <span data-ttu-id="2dd9d-573">在会话中间件保存会话失败的事件中（例如，如果后备存储不可用），中间件记录异常而请求继续正常进行。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-573">In the event that the session middleware fails to persist a session (for example, if the backing store isn't available), the middleware logs the exception and the request continues normally.</span></span> <span data-ttu-id="2dd9d-574">这会导致不可预知的行为。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-574">This leads to unpredictable behavior.</span></span>

  <span data-ttu-id="2dd9d-575">例如，用户将购物车存储在会话中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-575">For example, a user stores a shopping cart in session.</span></span> <span data-ttu-id="2dd9d-576">用户将商品添加到购物车，但提交失败。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-576">The user adds an item to the cart but the commit fails.</span></span> <span data-ttu-id="2dd9d-577">应用不知道有此失败，因此它向用户报告商品已添加到购物车，但事实并非如此。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-577">The app doesn't know about the failure so it reports to the user that the item was added to their cart, which isn't true.</span></span>

  <span data-ttu-id="2dd9d-578">检查此类错误的建议方法是完成将应用写入到该会话后，从应用代码调用 `await feature.Session.CommitAsync();`。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-578">The recommended approach to check for errors is to call `await feature.Session.CommitAsync();` from app code when the app is done writing to the session.</span></span> <span data-ttu-id="2dd9d-579">如果后备存储不可用，则 `CommitAsync` 引发异常。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-579">`CommitAsync` throws an exception if the backing store is unavailable.</span></span> <span data-ttu-id="2dd9d-580">如果 `CommitAsync` 失败，应用可以处理异常。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-580">If `CommitAsync` fails, the app can process the exception.</span></span> <span data-ttu-id="2dd9d-581">在与数据存储不可用的相同的条件下，`LoadAsync` 引发异常。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-581">`LoadAsync` throws under the same conditions where the data store is unavailable.</span></span>
  
## <a name="signalr-and-session-state"></a><span data-ttu-id="2dd9d-582">SignalR 和会话状态</span><span class="sxs-lookup"><span data-stu-id="2dd9d-582">SignalR and session state</span></span>

<span data-ttu-id="2dd9d-583">SignalR 应用不应使用会话状态来存储信息。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-583">SignalR apps should not use session state to store information.</span></span> <span data-ttu-id="2dd9d-584">SignalR 应用可以将每个连接状态存储在中心的 `Context.Items` 中。</span><span class="sxs-lookup"><span data-stu-id="2dd9d-584">SignalR apps can store per connection state in `Context.Items` in the hub.</span></span> <!-- https://github.com/aspnet/SignalR/issues/2139 -->

## <a name="additional-resources"></a><span data-ttu-id="2dd9d-585">其他资源</span><span class="sxs-lookup"><span data-stu-id="2dd9d-585">Additional resources</span></span>

<xref:host-and-deploy/web-farm>
::: moniker-end
